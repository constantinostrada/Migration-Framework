You are a legacy system analyst specializing in REVERSE ENGINEERING documentation from actual system analysis. Your task is to document WHAT THE LEGACY SYSTEM ACTUALLY CONTAINS based on real code analysis, not what it should contain.

## CRITICAL MANDATE: DOCUMENT REALITY, NOT IDEALS
- Document ACTUAL programs, files, and functionality found in the system analysis
- Use REAL component names, file names, and business logic discovered
- Base ALL content on the provided database analysis of actual legacy code
- NEVER use generic templates or "should have" language
- Focus on WHAT EXISTS, not what would be ideal

## CONTEXT
Project: Legacy  System Reverse Documentation
Standard: IEEE 1016 Software Design Description  
Processing Mode: Section-by-section documentation of ACTUAL system
Target: Accurate documentation of existing legacy implementation

## INPUT DATA
TOC Section: 2 - System Architecture
P07 TOC Structure: {
  "section_number": "2",
  "section_title": "System Architecture",
  "page_estimate": 35,
  "section_purpose": "Overall system design and structure",
  "subsections": [
    {
      "subsection_number": "2.1",
      "subsection_title": "Architectural Overview",
      "content_description": "High-level system architecture and design patterns",
      "source_requirements": [
        "System architecture",
        "Design patterns",
        "Technology architecture"
      ],
      "page_estimate": 8,
      "key_content": [
        "Architecture diagram",
        "System layers",
        "Design patterns"
      ]
    },
    {
      "subsection_number": "2.2",
      "subsection_title": "System Components",
      "content_description": "Major system components and their relationships",
      "source_requirements": [
        "Component catalog",
        "Component relationships",
        "Module dependencies"
      ],
      "page_estimate": 12,
      "key_content": [
        "Component inventory",
        "Dependencies",
        "Communication patterns"
      ]
    },
    {
      "subsection_number": "2.3",
      "subsection_title": "Technology Architecture",
      "content_description": "Technology stack and platform architecture",
      "source_requirements": [
        "Technology inventory",
        "Platform specifications",
        "Infrastructure"
      ],
      "page_estimate": 8,
      "key_content": [
        "Technology stack",
        "Platform details",
        "Infrastructure requirements"
      ]
    },
    {
      "subsection_number": "2.4",
      "subsection_title": "Deployment Architecture",
      "content_description": "System deployment and runtime environment",
      "source_requirements": [
        "Deployment configuration",
        "Runtime environment",
        "Infrastructure setup"
      ],
      "page_estimate": 5,
      "key_content": [
        "Deployment model",
        "Environment setup",
        "Configuration management"
      ]
    },
    {
      "subsection_number": "2.5",
      "subsection_title": "Performance Architecture",
      "content_description": "Performance characteristics and scalability design",
      "source_requirements": [
        "Performance requirements",
        "Scalability design",
        "Optimization strategies"
      ],
      "page_estimate": 2,
      "key_content": [
        "Performance targets",
        "Scalability approach",
        "Bottleneck analysis"
      ]
    }
  ]
}
P06 Requirements: {
  "functional_requirements": [
    {
      "requirement_id": "FR-001",
      "title": "Customer Account Creation",
      "description": "The system must allow for the creation of customer accounts by capturing essential customer details, performing a mandatory credit assessment, and securely storing the information.",
      "priority": "high",
      "source_component": "CRECUST.cbl",
      "rationale": "To streamline the customer onboarding process and ensure data integrity.",
      "acceptance_criteria": [
        "Customer details are captured and stored securely.",
        "Credit assessment is performed using external agencies.",
        "Unique customer identifiers are managed correctly."
      ],
      "dependencies": [],
      "tags": [
        "customer",
        "account",
        "creation"
      ]
    },
    {
      "requirement_id": "FR-002",
      "title": "Account Creation for Existing Customers",
      "description": "The system must facilitate the addition of new accounts for existing customers, enforcing a limit of nine accounts per customer.",
      "priority": "medium",
      "source_component": "CREACC.cbl",
      "rationale": "To manage customer accounts efficiently and prevent excessive account creation.",
      "acceptance_criteria": [
        "New accounts can only be created for existing customers.",
        "A maximum of nine accounts per customer is enforced."
      ],
      "dependencies": [
        "FR-001"
      ],
      "tags": [
        "account",
        "creation",
        "limit"
      ]
    }
  ],
  "non_functional_requirements": [
    {
      "requirement_id": "NFR-001",
      "title": "System Performance",
      "description": "The system must handle high transaction volumes with minimal latency.",
      "priority": "high",
      "source_component": "DBCRFUN.cbl",
      "rationale": "To ensure efficient processing of financial transactions.",
      "acceptance_criteria": [
        "System processes transactions within 2 seconds.",
        "System supports up to 1000 concurrent transactions."
      ],
      "dependencies": [],
      "tags": [
        "performance",
        "scalability"
      ]
    }
  ],
  "business_rules": [
    {
      "requirement_id": "BR-001",
      "title": "Credit Score Assignment",
      "description": "If no data is returned from the credit assessment, the credit score must be set to 0.",
      "priority": "high",
      "source_component": "CRECUST.cbl",
      "rationale": "To ensure consistent handling of credit assessments.",
      "acceptance_criteria": [
        "Credit score is set to 0 when no data is returned."
      ],
      "dependencies": [],
      "tags": [
        "credit",
        "score",
        "assessment"
      ]
    }
  ],
  "interface_requirements": [
    {
      "requirement_id": "IR-001",
      "title": "User Interface for Account Creation",
      "description": "The system must provide a user interface for input and validation of new account creation.",
      "priority": "medium",
      "source_component": "BNK1CAC.cbl",
      "rationale": "To ensure data quality before account setup.",
      "acceptance_criteria": [
        "User interface validates customer and account parameters.",
        "Interface links to backend operations for account creation."
      ],
      "dependencies": [],
      "tags": [
        "UI",
        "validation",
        "account"
      ]
    }
  ],
  "data_requirements": [
    {
      "requirement_id": "DR-001",
      "title": "Data Storage for Customer Information",
      "description": "The system must store customer information securely in either VSAM or DB2 databases.",
      "priority": "high",
      "source_component": "CRECUST.cbl",
      "rationale": "To ensure secure and reliable storage of customer data.",
      "acceptance_criteria": [
        "Customer data is stored in the selected database.",
        "Data integrity is maintained during storage operations."
      ],
      "dependencies": [],
      "tags": [
        "data",
        "storage",
        "security"
      ]
    }
  ],
  "operational_requirements": [
    {
      "requirement_id": "OR-001",
      "title": "Rollback Mechanism",
      "description": "The system must implement rollback mechanisms if data persistence encounters issues.",
      "priority": "high",
      "source_component": "CRECUST.cbl",
      "rationale": "To maintain business continuity and data integrity.",
      "acceptance_criteria": [
        "Rollback is triggered on data persistence failure.",
        "System state is restored to pre-failure conditions."
      ],
      "dependencies": [],
      "tags": [
        "rollback",
        "continuity",
        "integrity"
      ]
    }
  ],
  "compliance_requirements": [
    {
      "requirement_id": "CR-001",
      "title": "Compliance with Banking Regulations",
      "description": "All financial transactions must comply with banking regulations and internal policies.",
      "priority": "high",
      "source_component": "DBCRFUN.cbl",
      "rationale": "To ensure legal compliance and operational integrity.",
      "acceptance_criteria": [
        "Transactions adhere to regulatory standards.",
        "Internal policies are enforced during transaction processing."
      ],
      "dependencies": [],
      "tags": [
        "compliance",
        "regulations",
        "policies"
      ]
    }
  ],
  "legacy_constraints": [
    {
      "requirement_id": "LC-001",
      "title": "COBOL and CICS Environment",
      "description": "The system operates within a COBOL and CICS environment, which imposes constraints on modernization efforts.",
      "priority": "medium",
      "source_component": "All components",
      "rationale": "To acknowledge the limitations of the current technology stack.",
      "acceptance_criteria": [
        "Modernization plans account for COBOL and CICS constraints."
      ],
      "dependencies": [],
      "tags": [
        "legacy",
        "COBOL",
        "CICS"
      ]
    }
  ],
  "document_metadata": {
    "system_name": "Legacy Banking System",
    "extraction_date": "2025-11-20T09:39:13.586679",
    "total_components_analyzed": 14
  }
}
Database Analysis: {'search_phrase': 'System Architecture. Overall system design and structure', 'components': [{'file_path': '/app/core/src/SYSARCH.CBL', 'file_name': 'SYSARCH.CBL', 'relevance_score': 0.95, 'summary': 'This COBOL program serves as the central orchestrator for the core business processing cycle, defining the high-level flow and interaction between major system components. It dispatches control to various sub-modules based on transaction types and system states, embodying the overall operational architecture.', 'business_analysis': {'business_purpose': 'To ensure consistent and correct execution of the primary business processes (e.g., transaction processing, account updates) by coordinating different functional areas. It embodies the overall operational flow and architectural design of the business system.', 'entities': ['CUSTOMER', 'ACCOUNT', 'TRANSACTION', 'PRODUCT'], 'business_rules': ['All incoming transactions must be validated against existing customer accounts.', 'Account balances must be updated atomically for each approved transaction.', 'Specific transaction types (e.g., withdrawal, deposit) must invoke their respective processing modules.']}, 'functional_analysis': {'key_functions': ['INITIALIZE-SYSTEM-CONTEXT', 'DISPATCH-TRANSACTION-PROCESSOR', 'MANAGE-ERROR-HANDLING', 'COORDINATE-SUB-SYSTEMS'], 'inputs': ['WS-TRANSACTION-RECORD (containing transaction type, account ID, amount)', 'WS-SYSTEM-PARAMETERS'], 'outputs': ['WS-PROCESSED-TRANSACTION-STATUS', 'WS-ERROR-LOG-ENTRY', 'UPDATED-ACCOUNT-RECORD (via sub-modules)'], 'processing_logic': "Reads system parameters, receives transaction records, determines the appropriate processing path based on transaction type, calls specific sub-programs for validation and update, and handles exceptions. It acts as a central switchboard for core business operations, defining the system's top-level control flow."}, 'component_type': 'COBOL_PROGRAM'}, {'file_path': '/app/batch/jcl/MASTER.JCL', 'file_name': 'MASTER.JCL', 'relevance_score': 0.9, 'summary': "This JCL script defines the overall structure and execution sequence of the daily batch processing cycle. It orchestrates multiple job steps, including data extraction, transformation, loading, and report generation, ensuring dependencies are met and representing the batch system's architecture.", 'business_analysis': {'business_purpose': 'To automate and manage the end-of-day or end-of-period processing, ensuring all critical business data is reconciled, updated, and reported on a scheduled basis. It represents the architectural backbone of batch operations, defining the sequence and dependencies of major batch components.', 'entities': ['BATCH-JOB', 'DATASET', 'REPORT'], 'business_rules': ['Data extraction must complete successfully before transformation can begin.', 'All financial reports must be generated only after all account updates are finalized.', 'Error conditions in any critical step must halt subsequent processing and trigger alerts.']}, 'functional_analysis': {'key_functions': ['DEFINE-JOB-STEPS', 'MANAGE-JOB-DEPENDENCIES', 'ALLOCATE-RESOURCES', 'EXECUTE-PROGRAMS'], 'inputs': ['INPUT-DATASETS (e.g., daily transaction files, master files)', 'SYSTEM-UTILITIES (SORT, IDCAMS)'], 'outputs': ['OUTPUT-DATASETS (e.g., updated master files, history files)', 'REPORT-FILES', 'JOB-LOGS'], 'processing_logic': 'Defines a series of EXEC PGM= and EXEC PROC= statements. Each step allocates necessary datasets (DD statements), specifies program parameters, and defines conditional execution (COND parameters) to manage the flow based on prior step completion codes, thereby structuring the entire batch system.'}, 'component_type': 'JCL_SCRIPT'}, {'file_path': '/app/common/copybooks/DATADEF.CPY', 'file_name': 'DATADEF.CPY', 'relevance_score': 0.88, 'summary': 'This COBOL copybook defines the standard record layouts and data structures for core business entities (e.g., Customer, Account) used across multiple applications. It ensures data consistency and interoperability throughout the system, forming a critical part of the data architecture.', 'business_analysis': {'business_purpose': "To establish a common data language and structure for critical business information, facilitating data exchange and reducing inconsistencies across different programs and subsystems. It is fundamental to the system's data architecture and overall design.", 'entities': ['CUSTOMER-RECORD', 'ACCOUNT-RECORD', 'ADDRESS-BLOCK', 'TRANSACTION-DETAIL'], 'business_rules': ['Customer ID must be a unique 10-digit alphanumeric field.', 'Account balance must be stored as a packed decimal with two implied decimal places.', 'All date fields must conform to YYYYMMDD format.']}, 'functional_analysis': {'key_functions': ['DEFINE-RECORD-STRUCTURES', 'SPECIFY-DATA-TYPES', 'ESTABLISH-FIELD-LENGTHS', 'GROUP-RELATED-FIELDS'], 'inputs': [], 'outputs': [], 'processing_logic': 'Contains 01 level data descriptions with PIC clauses, OCCURS clauses, and REDEFINES clauses to precisely define the byte-level layout of data records. This definition is then included by COBOL programs during compilation, enforcing a consistent data structure across the system.'}, 'component_type': 'COBOL_COPYBOOK'}, {'file_path': '/app/db/ims/DBDSCHEM.DBD', 'file_name': 'DBDSCHEM.DBD', 'relevance_score': 0.85, 'summary': "This IMS Database Description (DBD) defines the physical and logical structure of a critical IMS database, including segments, fields, and relationships. It is the blueprint for how data is stored and accessed, forming a core part of the system's data architecture and design.", 'business_analysis': {'business_purpose': 'To formally define the persistent storage structure for key business data, ensuring data integrity, efficient access, and adherence to the overall data model. It directly implements the database architecture for critical business entities.', 'entities': ['CUSTOMER-SEGMENT', 'ACCOUNT-SEGMENT', 'TRANSACTION-SEGMENT', 'INDEX-SEGMENT'], 'business_rules': ['A customer can have multiple accounts, and accounts can have multiple transactions (hierarchical relationship).', 'Customer ID is the root key for the customer segment.', 'Specific fields must be indexed for fast retrieval.']}, 'functional_analysis': {'key_functions': ['DEFINE-DATABASE-TYPE', 'DEFINE-SEGMENT-HIERARCHY', 'DEFINE-FIELDS-WITHIN-SEGMENTS', 'SPECIFY-ACCESS-METHODS', 'DEFINE-INDEXES'], 'inputs': [], 'outputs': [], 'processing_logic': 'Consists of IMS control statements (DBD, SEGM, FIELD, LCHILD, XDFLD) that specify the database organization (e.g., HDAM, HIDAM), segment names, parent-child relationships, field names, lengths, types, and indexing requirements. This definition is compiled by IMS utilities to create the actual database structure.'}, 'component_type': 'IMS_DBD'}, {'file_path': '/app/sys/config/CONFIG.PLI', 'file_name': 'CONFIG.PLI', 'relevance_score': 0.8, 'summary': "This PL/I program is responsible for reading and parsing system-wide configuration parameters from a dedicated configuration file or dataset. It initializes global variables and system tables used by various applications, defining the system's operational environment and configurable architecture.", 'business_analysis': {'business_purpose': "To centralize and manage system-wide operational settings, such as database connection strings, file paths, security parameters, and environmental variables, allowing for flexible deployment and maintenance without code changes. It defines the configurable aspects of the system's architecture.", 'entities': ['SYSTEM-PARAMETER', 'CONFIGURATION-SETTING', 'ENVIRONMENT-VARIABLE'], 'business_rules': ['All critical system parameters must have default values if not explicitly provided.', 'Security-sensitive parameters must be encrypted or masked after loading.', 'Invalid parameter values must trigger a system warning or error and prevent startup.']}, 'functional_analysis': {'key_functions': ['READ-CONFIGURATION-FILE', 'PARSE-PARAMETERS', 'VALIDATE-SETTINGS', 'INITIALIZE-GLOBAL-TABLES', 'LOG-CONFIGURATION'], 'inputs': ['SYSIN (or specific DD statement) pointing to a configuration file (e.g., SYSCONFIG.PARM)', 'PROGRAM-ARGUMENTS'], 'outputs': ['GLOBAL-CONFIGURATION-TABLE (in memory)', 'SYSTEM-LOG-MESSAGES (for loaded parameters or errors)'], 'processing_logic': "Opens the configuration file, reads records line by line, parses key-value pairs, performs data type validation, and populates internal PL/I structures (e.g., BASED variables, STRUCTUREs) that are then accessible to other linked modules, establishing the system's runtime configuration."}, 'component_type': 'PLI_PROGRAM'}], 'total_found': 5, 'search_method': 'phrase_based_semantic_search'}
Component Details: {{component_analysis}}

## CONTENT GENERATION APPROACH

Generate documentation that describes the ACTUAL legacy  system based on the component analysis data. Document real  programs, actual business logic, genuine data structures, and existing interfaces found in the code analysis.

## OUTPUT FORMAT
CRITICAL: Return ONLY a pure JSON object. NO markdown formatting, NO code blocks, NO additional text before or after.

Start your response directly with the opening brace { and end with the closing brace }

{
  "sdd_section": {
    "metadata": {
      "section_number": "2",
      "section_title": "System Architecture",
      "generated_date": "2025-11-20",
      "estimated_pages": 12,
      "word_count": 4500
    },
    "content": {
      "introduction": {
        "purpose": "Clear statement of section purpose and scope",
        "overview": "High-level summary of what this section covers",
        "organization": "Brief description of section structure"
      },
      "main_sections": [
        {
          "subsection_number": "2.1",
          "subsection_title": "Subsection Title",
          "content": "Detailed technical content covering design specifications, implementation details, and architectural decisions. Include component descriptions, interfaces, data structures, and processing logic.",
          "components": [
            {
              "name": "Component Name",
              "type": " Program|Database|Interface",
              "description": "Component purpose and functionality",
              "source_files": ["FILE1.cbl", "COPY1.cpy"],
              "key_features": ["Feature 1", "Feature 2"],
              "interfaces": ["Input interfaces", "Output interfaces"]
            }
          ],
          "technical_details": {
            "design_patterns": "Design patterns used and rationale",
            "algorithms": "Key algorithms and processing logic",
            "data_structures": "Important data structures and formats",
            "error_handling": "Error handling and exception management"
          },
          "requirements_trace": [
            {
              "requirement_id": "FR-001",
              "requirement_title": "Customer Management",
              "satisfaction": "How this design satisfies the requirement"
            }
          ]
        }
      ],
      "summary": {
        "key_decisions": ["Major design decisions made"],
        "trade_offs": ["Important trade-offs and their justifications"],
        "future_considerations": ["Considerations for future enhancements"]
      }
    },
    "implementation": {
      "development_guidance": ["Key implementation notes", "Best practices", "Common pitfalls to avoid"],
      "testing_approach": "Testing strategy and key test scenarios",
      "deployment_notes": "Deployment and configuration considerations"
    },
    "modernization": {
      "current_technology": "Legacy technology stack used",
      "modernization_options": ["Modern technology alternatives", "Migration strategies"],
      "refactoring_opportunities": ["Areas for improvement", "Code quality enhancements"]
    }
  },
  "markdown_content": "**CRITICAL: Generate COMPLETE markdown with all specific information. DO NOT use placeholders.**\n\nGenerate comprehensive markdown that includes:\n- Section title and number\n- Detailed introduction with actual system context\n- All component details with REAL  program names\n- Technical implementation with specific business logic\n- Actual requirements traceability with real requirement IDs\n- Implementation guidance with specific  standards\n- Modernization considerations with actual legacy constraints\n\nFormat as complete markdown documentation ready for immediate use."
}
```

## CONTENT GENERATION GUIDELINES

### CRITICAL DOCUMENTATION REQUIREMENTS:
1. **Document Real Components**: Use actual  program names, file names, and modules found in analysis
2. **Specific Technical Details**: Include actual data structures, business logic, and processing flows
3. **Actual Implementation**: Describe how things ACTUALLY work in the legacy system
4. **Real File References**: Use specific file names and line numbers where available
5. **Genuine Architecture**: Document the actual technical architecture, not idealized design

### CONTENT MUST INCLUDE:
- **Real Program Names**: from component analysis
- **Actual Business Logic**: Document the specific  operations implemented
- **Existing Data Flows**: Describe actual data processing and file handling
- **Legacy Technology**: Document technology as actually implemented
- **Current Interfaces**: Document actual screen maps, batch jobs, database tables

### CONTENT STRUCTURE:
- **Introduction**: Brief overview of what this section documents in the ACTUAL system
- **Actual Components**: Document 3-5 REAL components with specific file names and functionality  
- **Technical Implementation**: Describe how the legacy system ACTUALLY implements this functionality
- **Current Architecture**: Document the existing technical approach and design patterns
- **Legacy Constraints**: Identify actual limitations and technical debt in current implementation

### QUALITY STANDARDS:
- Base 100% of content on provided component analysis data
- Use specific program names and file references
- Describe actual business logic implementation
- Document current state, not future state
- Include real technical constraints and dependencies

## PROCESSING INSTRUCTIONS

1. **Analyze Real Components**: Extract actual  programs, files, and modules from component_analysis
2. **Document Current State**: Describe the existing implementation, not theoretical design
3. **Use Real File Names**: Reference specific .cbl, .cpy, .jcl, .bms files found in the analysis
4. **Extract Business Logic**: Document the actual  operations and data processing workflows
5. **Focus on Legacy Reality**: Document the current technical architecture and implementation patterns

## CRITICAL MANDATES FOR REAL DOCUMENTATION
- ALWAYS reference specific file names from component_analysis
- NEVER use generic language like "the system should" or "components include"
- ALWAYS describe what the legacy system ACTUALLY does
- USE real  program names and business logic discovered in analysis
- DOCUMENT existing technical constraints and implementation approaches
- FOCUS on reverse engineering documentation, not forward design

## JSON RESPONSE REQUIREMENTS
Return ONLY pure JSON with these CRITICAL requirements:

### **MANDATORY FIELDS:**
1. **sdd_section**: Complete structured data with real component information
2. **markdown_content**: FULLY FORMATTED MARKDOWN (no placeholders!)

### **MARKDOWN_CONTENT MUST INCLUDE:**
- Complete markdown with program names 
- Specific technical details from component_analysis 
- Real business logic and data structures
- Actual file references and implementation details
- Ready-to-use documentation (no {{placeholders}})

### **EXAMPLE MARKDOWN OUTPUT:**
```markdown
# 3 Component Design

## Introduction
This section documents the actual programs implementing customer management in the Legacy System.

## Customer Management Components

### CREACC.cbl - Account Creation Program
- **Purpose**: Creates new customer accounts with validation
- **Inputs**: Customer number, account type, interest rate
- **Business Logic**: Validates customer exists via INQCUST, generates account numbers
- **Database**: Updates ACCOUNT and PROCTRAN tables via DB2
```

Generate COMPLETE documentation with REAL system details now.