{
  "project_info": {
    "name": "Legacy Banking System Modernization",
    "description": "Modernization of a legacy COBOL banking system to Next.js, Python, and PostgreSQL",
    "tech_stack": {
      "original": "COBOL, CICS, DB2, VSAM",
      "target": {
        "frontend": "Next.js (React, TypeScript)",
        "backend": "Python (FastAPI/Flask)",
        "database": "PostgreSQL",
        "deployment": "Docker, CI/CD"
      }
    },
    "total_requirements": 121,
    "functional_requirements": 78,
    "non_functional_requirements": 43
  },
  "task_generation_metadata": {
    "generated_date": "2026-01-02",
    "source_documents": [
      "extracted_requirements.json",
      "extracted_requirements_summary.md",
      "Legacy Banking System SDD"
    ],
    "total_tasks": 85,
    "phases": 5
  },
  "tasks": [
    {
      "id": "TASK-001",
      "title": "Initialize Next.js Frontend Project Structure",
      "description": "Create a new Next.js project with TypeScript at path ./frontend. Use 'npx create-next-app@latest frontend --typescript --tailwind --eslint --app --src-dir --import-alias @/*'. Configure tsconfig.json with strict mode enabled. Create directory structure: src/app (Next.js 13+ app router), src/components (reusable UI components), src/lib (utilities and helpers), src/types (TypeScript type definitions), src/services (API client services). Install additional dependencies: axios (HTTP client), react-hook-form (form handling), zod (validation), @tanstack/react-query (data fetching). Create .env.local file with NEXT_PUBLIC_API_URL variable pointing to http://localhost:8000.",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "30 minutes",
      "dependencies": [],
      "acceptanceCriteria": [
        "Next.js project created with TypeScript and Tailwind CSS",
        "Directory structure matches specification (app, components, lib, types, services)",
        "Required dependencies installed (axios, react-hook-form, zod, react-query)",
        ".env.local exists with API URL configuration",
        "Project builds successfully with 'npm run build'",
        "No TypeScript compilation errors"
      ],
      "relatedRequirements": ["NFR-5", "NFR-17", "NFR-28"],
      "skillsRequired": ["Next.js", "TypeScript", "Node.js"],
      "deliverables": [
        "frontend/package.json",
        "frontend/tsconfig.json",
        "frontend/.env.local",
        "frontend/src/app/",
        "frontend/src/components/",
        "frontend/src/lib/",
        "frontend/src/types/",
        "frontend/src/services/"
      ]
    },
    {
      "id": "TASK-002",
      "title": "Initialize Python Backend Project Structure",
      "description": "Create Python backend project at path ./backend using FastAPI. Create pyproject.toml using Poetry with dependencies: fastapi (web framework), uvicorn (ASGI server), sqlalchemy (ORM), psycopg2-binary (PostgreSQL driver), pydantic (data validation), python-jose (JWT), passlib (password hashing), python-multipart (file uploads), pytest (testing), alembic (migrations), python-dotenv (environment variables). Create directory structure: backend/app (main application), backend/app/api (API routes), backend/app/core (configuration and security), backend/app/models (database models), backend/app/schemas (Pydantic schemas), backend/app/services (business logic), backend/app/db (database utilities), backend/tests (test suite). Create .env file with DATABASE_URL=postgresql://user:password@localhost:5432/banking_db, SECRET_KEY=your-secret-key-here, API_V1_PREFIX=/api/v1. Create backend/app/main.py with FastAPI app initialization, CORS middleware, and health check endpoint at /health.",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "45 minutes",
      "dependencies": [],
      "acceptanceCriteria": [
        "Python project created with Poetry and FastAPI",
        "Directory structure matches specification (api, core, models, schemas, services, db, tests)",
        "All required dependencies listed in pyproject.toml",
        ".env file exists with database configuration",
        "main.py creates FastAPI app with CORS and health check endpoint",
        "Server starts successfully with 'uvicorn app.main:app --reload'",
        "Health check endpoint returns 200 status"
      ],
      "relatedRequirements": ["NFR-5", "NFR-8", "NFR-28"],
      "skillsRequired": ["Python", "FastAPI", "Poetry"],
      "deliverables": [
        "backend/pyproject.toml",
        "backend/.env",
        "backend/app/main.py",
        "backend/app/api/",
        "backend/app/core/",
        "backend/app/models/",
        "backend/app/schemas/",
        "backend/app/services/",
        "backend/app/db/",
        "backend/tests/"
      ]
    },
    {
      "id": "TASK-003",
      "title": "Setup PostgreSQL Database Schema with Core Tables",
      "description": "Create Alembic migration script at backend/alembic/versions/001_initial_schema.py. Define CUSTOMER table with columns: id (BIGSERIAL PRIMARY KEY), customer_number (VARCHAR(10) UNIQUE NOT NULL), eyecatcher (CHAR(4) DEFAULT 'CUST'), title (VARCHAR(20) CHECK IN ('Mr','Mrs','Miss','Ms','Dr','Professor','Drs','Lord','Sir','Lady')), first_name (VARCHAR(50) NOT NULL), surname (VARCHAR(50) NOT NULL), date_of_birth (DATE NOT NULL CHECK > '1600-01-01'), address_line1 (VARCHAR(100) NOT NULL), address_line2 (VARCHAR(100)), address_line3 (VARCHAR(100)), city (VARCHAR(50)), postal_code (VARCHAR(20)), credit_score (INTEGER CHECK BETWEEN 0 AND 999), marked_for_review (BOOLEAN DEFAULT FALSE), created_at (TIMESTAMP DEFAULT NOW()), updated_at (TIMESTAMP DEFAULT NOW()), deleted_at (TIMESTAMP NULL). Create index on customer_number. Define ACCOUNT table with columns: id (BIGSERIAL PRIMARY KEY), account_number (VARCHAR(20) UNIQUE NOT NULL), customer_id (BIGINT REFERENCES CUSTOMER(id) ON DELETE CASCADE), account_type (VARCHAR(20) CHECK IN ('ISA','MORTGAGE','SAVING','CURRENT','LOAN') NOT NULL), interest_rate (NUMERIC(5,2) DEFAULT 0.00), overdraft_limit (NUMERIC(15,2) DEFAULT 0.00 CHECK >= 0), available_balance (NUMERIC(15,2) DEFAULT 0.00), actual_balance (NUMERIC(15,2) DEFAULT 0.00), last_statement_date (DATE), next_statement_date (DATE), opened_date (DATE NOT NULL), created_at (TIMESTAMP DEFAULT NOW()), updated_at (TIMESTAMP DEFAULT NOW()), deleted_at (TIMESTAMP NULL). Add CHECK constraint: opened_date must be after customer date_of_birth. Create indexes on customer_id and account_number. Define PROCTRAN table with columns: id (BIGSERIAL PRIMARY KEY), eyecatcher (CHAR(4) DEFAULT 'PRTR'), transaction_code (VARCHAR(3) CHECK IN ('CHA','CHF','CHI','CHO','CRE','DEB','ICA','ICC','IDA','IDC','OCA','OCC','ODA','ODC','OCS','PCR','PDR','TFR')), account_id (BIGINT REFERENCES ACCOUNT(id)), customer_id (BIGINT REFERENCES CUSTOMER(id)), amount (NUMERIC(15,2)), description (TEXT), transaction_timestamp (TIMESTAMP DEFAULT NOW()), deleted_flag (CHAR(1) DEFAULT NULL). Create indexes on account_id, customer_id, and transaction_timestamp.",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "60 minutes",
      "dependencies": ["TASK-002"],
      "acceptanceCriteria": [
        "Alembic migration file 001_initial_schema.py exists",
        "CUSTOMER table created with all specified columns and constraints",
        "Title validation enforces 10 valid values",
        "Date of birth CHECK constraint validates year > 1600",
        "ACCOUNT table created with foreign key to CUSTOMER",
        "Account type validation enforces 5 valid values (ISA, MORTGAGE, SAVING, CURRENT, LOAN)",
        "CHECK constraint ensures opened_date > customer DOB",
        "PROCTRAN table created with eyecatcher and 18 transaction type codes",
        "All indexes created successfully",
        "Migration applies successfully with 'alembic upgrade head'",
        "All constraints are enforced at database level"
      ],
      "relatedRequirements": ["FR-1", "FR-9", "FR-10", "FR-12", "FR-21", "NFR-10"],
      "skillsRequired": ["PostgreSQL", "SQL", "Alembic"],
      "deliverables": [
        "backend/alembic/versions/001_initial_schema.py"
      ]
    },
    {
      "id": "TASK-004",
      "title": "Create SQLAlchemy Database Models",
      "description": "Create backend/app/models/customer.py with Customer model class inheriting from SQLAlchemy Base. Define all columns matching database schema: id, customer_number, eyecatcher (default='CUST'), title, first_name, surname, date_of_birth, address fields (line1, line2, line3, city, postal_code), credit_score, marked_for_review, timestamps (created_at, updated_at, deleted_at). Add relationship to Account model with cascade delete. Add @validates decorator for title (must be in valid list), date_of_birth (must be after 1600, calculated age < 150 years). Create backend/app/models/account.py with Account model class. Define columns: id, account_number, customer_id (ForeignKey), account_type, interest_rate, overdraft_limit, available_balance, actual_balance, statement dates, opened_date, timestamps. Add relationship to Customer model and PROCTRAN. Add @validates decorator for account_type (must be in valid list, not spaces/low-values), overdraft_limit (>= 0). Create backend/app/models/transaction.py with ProcTran model class. Define columns: id, eyecatcher (default='PRTR'), transaction_code, account_id (ForeignKey), customer_id (ForeignKey), amount, description, transaction_timestamp, deleted_flag. Add @validates for transaction_code (must be one of 18 valid codes), amount (must be > 0). Create backend/app/models/__init__.py importing all models. Create backend/app/db/session.py with SQLAlchemy engine setup, SessionLocal factory using DATABASE_URL from environment, and get_db() dependency function for FastAPI.",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "60 minutes",
      "dependencies": ["TASK-002", "TASK-003"],
      "acceptanceCriteria": [
        "Customer model created with all fields and validations",
        "Title validation enforces 10 valid values in code",
        "Age validation ensures calculated age < 150 years",
        "Account model created with foreign key to Customer",
        "Account type validation implemented with @validates",
        "ProcTran model created with eyecatcher 'PRTR'",
        "Transaction code validation enforces 18 valid codes",
        "Amount validation ensures positive values only",
        "Cascade delete relationship configured on Customer -> Account",
        "SQLAlchemy session factory created in db/session.py",
        "get_db() dependency function returns database session",
        "All models properly imported in __init__.py"
      ],
      "relatedRequirements": ["FR-7", "FR-9", "FR-19", "FR-42", "NFR-7"],
      "skillsRequired": ["Python", "SQLAlchemy", "Database Modeling"],
      "deliverables": [
        "backend/app/models/customer.py",
        "backend/app/models/account.py",
        "backend/app/models/transaction.py",
        "backend/app/models/__init__.py",
        "backend/app/db/session.py"
      ]
    },
    {
      "id": "TASK-005",
      "title": "Create Pydantic Schemas for API Validation",
      "description": "Create backend/app/schemas/customer.py with CustomerBase schema defining: title (Literal with 10 valid values), first_name (str, min_length=1), surname (str, min_length=1), date_of_birth (date), address_line1 (str, min_length=1), optional address_line2/3, city, postal_code. Add @validator for date_of_birth: must not be in future, year > 1600, calculated age < 150. Add @validator for title to ensure it's in valid list. Create CustomerCreate schema inheriting CustomerBase. Create CustomerUpdate schema with all optional fields. Create CustomerResponse schema with id, customer_number, credit_score, marked_for_review, timestamps. Create backend/app/schemas/account.py with AccountBase schema: account_type (Literal['ISA','MORTGAGE','SAVING','CURRENT','LOAN']), interest_rate (condecimal ge=0, le=100), overdraft_limit (condecimal ge=0), statement dates (optional date). Add @validator for account_type to reject spaces, low-values, or starting with space. Create AccountCreate schema requiring customer_id. Create AccountUpdate with optional fields, explicit prohibition of balance fields in comments. Create AccountResponse with id, account_number, balances (available_balance, actual_balance), opened_date, timestamps. Create backend/app/schemas/transaction.py with TransactionBase: transaction_code (Literal with 18 codes), account_id, amount (condecimal gt=0), description (optional). Add @validator ensuring amount > 0. Create TransactionCreate and TransactionResponse schemas. Create backend/app/schemas/__init__.py importing all schemas.",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "60 minutes",
      "dependencies": ["TASK-004"],
      "acceptanceCriteria": [
        "CustomerBase schema with all required field validations",
        "Title validation uses Literal type with 10 values",
        "Date of birth validator checks future date, year > 1600, age < 150",
        "Required field validation for first_name, surname, address_line1",
        "AccountBase schema with account_type Literal (5 values)",
        "Account type validator rejects spaces and invalid formats",
        "Overdraft limit validation ensures non-negative values",
        "AccountUpdate schema explicitly excludes balance updates (commented)",
        "TransactionBase schema with transaction_code Literal (18 codes)",
        "Amount validator ensures positive values only (> 0)",
        "All Create, Update, Response schemas properly inherit base schemas",
        "All schemas imported in __init__.py"
      ],
      "relatedRequirements": ["FR-7", "FR-8", "FR-35", "FR-42", "FR-44", "FR-45", "FR-46", "NFR-7"],
      "skillsRequired": ["Python", "Pydantic", "Data Validation"],
      "deliverables": [
        "backend/app/schemas/customer.py",
        "backend/app/schemas/account.py",
        "backend/app/schemas/transaction.py",
        "backend/app/schemas/__init__.py"
      ]
    },
    {
      "id": "TASK-006",
      "title": "Implement JWT Authentication and Security Core",
      "description": "Create backend/app/core/config.py with Settings class using pydantic BaseSettings. Define: DATABASE_URL, SECRET_KEY, ALGORITHM='HS256', ACCESS_TOKEN_EXPIRE_MINUTES=30, API_V1_PREFIX='/api/v1', PROJECT_NAME='Banking System API'. Load from environment with Config(env_file='.env'). Create backend/app/core/security.py with functions: create_access_token(data: dict, expires_delta: timedelta) using python-jose JWT encoding with SECRET_KEY and ALGORITHM. Add verify_password(plain_password: str, hashed_password: str) using passlib bcrypt. Add get_password_hash(password: str) returning bcrypt hash. Create get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) dependency that: 1) Decodes JWT token, 2) Validates token hasn't expired, 3) Extracts user_id from payload, 4) Queries database for user, 5) Returns user object or raises 401 HTTPException. Create backend/app/core/deps.py with reusable dependencies: get_current_active_user (checks user is not disabled), require_admin (checks user has admin role). Create backend/app/api/v1/endpoints/auth.py with POST /login endpoint accepting username/password, validating credentials against database, returning JWT access token and token_type='bearer'. Add rate limiting to prevent brute force (100 requests per minute per IP).",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "60 minutes",
      "dependencies": ["TASK-002", "TASK-004"],
      "acceptanceCriteria": [
        "Settings class loads configuration from environment",
        "JWT token creation function with configurable expiration",
        "Password hashing using bcrypt with proper salt rounds",
        "Password verification function for authentication",
        "get_current_user dependency validates JWT tokens",
        "Invalid tokens raise 401 HTTPException with proper message",
        "Expired tokens are rejected",
        "/api/v1/auth/login endpoint accepts username and password",
        "Successful login returns JWT token and token_type",
        "Invalid credentials return 401 status",
        "Rate limiting prevents brute force attacks (100 req/min)",
        "Passwords never logged or returned in responses"
      ],
      "relatedRequirements": ["NFR-12", "NFR-13", "NFR-14", "NFR-16"],
      "skillsRequired": ["Python", "FastAPI", "JWT", "Security"],
      "deliverables": [
        "backend/app/core/config.py",
        "backend/app/core/security.py",
        "backend/app/core/deps.py",
        "backend/app/api/v1/endpoints/auth.py"
      ]
    },
    {
      "id": "TASK-007",
      "title": "Implement Centralized Error Handling and Logging",
      "description": "Create backend/app/core/errors.py defining custom exception classes: BankingException(base), CustomerNotFoundException, AccountNotFoundException, InsufficientFundsException, ValidationException, DatabaseConnectionException. Each exception has error_code (unique string), message, http_status_code, and optional details dict. Create backend/app/core/logging_config.py configuring Python logging with: JSON formatter for structured logs, log level from environment (default INFO), file handler writing to logs/app.log with rotation (max 10MB, 5 backups), console handler for development, correlation_id tracking for request tracing. Create middleware in backend/app/middleware/error_handler.py catching all exceptions: log full stack trace with timestamp and correlation_id, return standardized JSON error response {error_code, message, details, timestamp}, map exceptions to HTTP status codes, ensure 500 for unhandled exceptions. Create backend/app/middleware/request_logging.py middleware logging all requests: method, path, query params (sanitized), status code, duration, user_id (if authenticated), correlation_id. Create backend/app/services/monitoring.py with error notification function send_error_alert(error, severity) integrating with monitoring system. Register all middleware in main.py before routes.",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "60 minutes",
      "dependencies": ["TASK-002", "TASK-006"],
      "acceptanceCriteria": [
        "Custom exception classes defined with error codes and HTTP status",
        "Logging configured with JSON formatter for structured logs",
        "Log rotation configured (10MB max, 5 backups)",
        "Correlation ID generated and tracked across requests",
        "Error handler middleware catches all exceptions",
        "Stack traces logged with timestamp and context",
        "Standardized error JSON response format",
        "Request logging middleware logs method, path, duration, user",
        "Sensitive data (passwords, tokens) excluded from logs",
        "Error notifications sent to monitoring system",
        "Middleware registered in main.py before routes"
      ],
      "relatedRequirements": ["FR-5", "FR-30", "NFR-27"],
      "skillsRequired": ["Python", "FastAPI", "Logging"],
      "deliverables": [
        "backend/app/core/errors.py",
        "backend/app/core/logging_config.py",
        "backend/app/middleware/error_handler.py",
        "backend/app/middleware/request_logging.py",
        "backend/app/services/monitoring.py"
      ]
    },
    {
      "id": "TASK-008",
      "title": "Implement Retry Logic and Circuit Breaker Patterns",
      "description": "Create backend/app/core/retry.py with decorator @retry_on_exception accepting parameters: max_retries (int), backoff_strategy ('exponential' or 'fixed'), initial_delay (float), max_delay (float), retriable_exceptions (tuple of exception classes). Implement exponential backoff: delay = min(initial_delay * (2 ** attempt), max_delay). Log each retry attempt with attempt number and delay. Create @circuit_breaker decorator accepting: failure_threshold (int), timeout_duration (seconds), success_threshold (int to close circuit). Implement states: CLOSED (normal), OPEN (failing, reject requests), HALF_OPEN (testing recovery). When threshold failures reached, open circuit for timeout_duration. After timeout, enter HALF_OPEN, allow one request. If succeeds, close circuit. Track state per decorated function using function name as key. Create backend/app/services/database_resilience.py with function execute_with_retry(operation: Callable, operation_name: str) configured for database operations: 100 retries for SYSIDERR (system ID error), exponential backoff starting 100ms, max delay 5 seconds, retry on OperationalError (connection loss, deadlock, timeout). Log each attempt. On SQLCODE 923 (connection loss), trigger reconnection attempt. After max retries exhausted, raise DatabaseConnectionException. Create backend/app/services/external_api_resilience.py with async function call_credit_agency_with_circuit_breaker(agency_url: str, customer_data: dict) implementing: timeout 3 seconds, circuit breaker with failure_threshold=5, on failure return default score 0 and mark customer for review, 3 retries with exponential backoff. Test retry logic with unit tests mocking failures.",
      "suggestedPhase": "PHASE-01",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-002", "TASK-007"],
      "acceptanceCriteria": [
        "Retry decorator with configurable max_retries and backoff strategy",
        "Exponential backoff implemented correctly (2^attempt)",
        "Fixed interval backoff option available",
        "Each retry attempt logged with attempt number and delay",
        "Circuit breaker decorator with CLOSED, OPEN, HALF_OPEN states",
        "Circuit opens after failure_threshold consecutive failures",
        "Circuit stays open for timeout_duration seconds",
        "Half-open state allows test request before fully closing",
        "Database retry logic: 100 retries for SYSIDERR",
        "SQLCODE 923 (connection loss) triggers reconnection",
        "Credit agency calls timeout after 3 seconds",
        "Credit agency circuit breaker returns score=0 on failure",
        "Failed credit checks mark customer for review",
        "Unit tests verify retry behavior with mocked failures"
      ],
      "relatedRequirements": ["FR-6", "NFR-2", "NFR-6", "NFR-32", "NFR-33"],
      "skillsRequired": ["Python", "Async Programming", "Resilience Patterns"],
      "deliverables": [
        "backend/app/core/retry.py",
        "backend/app/services/database_resilience.py",
        "backend/app/services/external_api_resilience.py",
        "backend/tests/test_retry_logic.py"
      ]
    },
    {
      "id": "TASK-009",
      "title": "Create Customer Management Service with Validation",
      "description": "Create backend/app/services/customer_service.py with class CustomerService. Implement create_customer(customer_data: CustomerCreate, db: Session) -> Customer: 1) Generate unique customer_number using sequence or UUID, 2) Validate title is in approved list, 3) Validate DOB: not future, year > 1600, age < 150, 4) Validate required fields: first_name, surname, address_line1 not empty/whitespace, 5) Set eyecatcher='CUST', 6) Create Customer model instance, 7) Commit to database with retry logic, 8) Log creation in audit trail, 9) Return created customer. Implement get_customer(customer_number: str, db: Session) -> Customer handling special cases: if customer_number == '0000000000', select random customer with up to 1000 retry attempts until found; if customer_number == '9999999999', return last customer ordered by id DESC; else query by customer_number. Raise CustomerNotFoundException if not found. Implement update_customer(customer_number: str, customer_data: CustomerUpdate, db: Session) -> Customer: 1) Fetch existing customer, 2) Validate updates (title, DOB, required fields), 3) Update only provided fields, 4) Log update in audit trail, 5) Return updated customer. Implement delete_customer(customer_number: str, db: Session) -> bool: 1) Fetch customer with associated accounts, 2) Delete all accounts first (cascading), 3) Log each account deletion in PROCTRAN with transaction_code='ODC' or 'IDC', 4) Delete customer record, 5) Log customer deletion in PROCTRAN, 6) Idempotent: if already deleted, return success. Implement list_customers(skip: int, limit: int, db: Session) -> List[Customer] with pagination. Add execute_with_retry wrapper for all database operations.",
      "suggestedPhase": "PHASE-02",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-004", "TASK-005", "TASK-007", "TASK-008"],
      "acceptanceCriteria": [
        "create_customer validates all fields before database insert",
        "Customer number generation uses sequence or UUID",
        "Title validation enforces 10 valid values",
        "DOB validation: not future, year > 1600, age < 150",
        "Required fields validated: first_name, surname, address_line1",
        "Eyecatcher 'CUST' set automatically",
        "get_customer handles special mode 0000000000 (random customer)",
        "Random customer selection retries up to 1000 times",
        "get_customer handles special mode 9999999999 (last customer)",
        "update_customer validates all updates before applying",
        "Audit trail logs all create/update operations",
        "delete_customer implements cascading deletion (accounts first)",
        "Each deletion logged in PROCTRAN with appropriate code",
        "Deletion is idempotent (already-deleted returns success)",
        "Database operations wrapped with retry logic",
        "Pagination implemented in list_customers"
      ],
      "relatedRequirements": ["FR-1", "FR-7", "FR-22", "FR-38", "FR-44", "FR-45", "FR-46"],
      "skillsRequired": ["Python", "SQLAlchemy", "Business Logic"],
      "deliverables": [
        "backend/app/services/customer_service.py"
      ]
    },
    {
      "id": "TASK-010",
      "title": "Create Account Management Service with Business Rules",
      "description": "Create backend/app/services/account_service.py with class AccountService. Implement create_account(account_data: AccountCreate, db: Session) -> Account: 1) Validate customer exists, 2) Count existing accounts for customer, 3) Enforce limit: max 9 accounts per customer in online mode, raise exception if exceeded, 4) Generate unique account_number using named counter mechanism (sequence), 5) Validate account_type is one of ISA/MORTGAGE/SAVING/CURRENT/LOAN, not spaces/low-values, 6) Validate opened_date is after customer date_of_birth (cross-table check), 7) Set initial balances to 0.00, 8) Create Account model instance, 9) Commit with retry logic, 10) Log creation in PROCTRAN with transaction_code='OCA' or 'ICA', 11) Return created account. Implement get_account(account_number: str, db: Session) -> Account handling special case: if account_number == '99999999', execute alternative retrieval logic for system testing. Validate account_type not spaces/low-values/start-with-space. Implement update_account(account_number: str, account_data: AccountUpdate, db: Session) -> Account: 1) Fetch existing account, 2) CRITICAL: Explicitly prohibit balance updates (check AccountUpdate schema), 3) Allow updates: account_type, interest_rate, overdraft_limit, statement_dates, 4) Validate account_type not spaces/low-values, 5) Validate overdraft_limit >= 0, 6) Log update in audit trail, 7) Return updated account. Implement delete_account(account_number: str, db: Session) -> bool: 1) Fetch account, 2) Validate customer_id and account_type match if provided, 3) Delete account record, 4) Log deletion in PROCTRAN with code 'ODA' or 'IDA', 5) Idempotent: if already deleted, return success without error. Implement list_accounts_for_customer(customer_number: str, db: Session) -> List[Account].",
      "suggestedPhase": "PHASE-02",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-004", "TASK-005", "TASK-009"],
      "acceptanceCriteria": [
        "create_account validates customer exists before creation",
        "Account limit enforced: max 9 accounts per customer (online mode)",
        "Account number generated using named counter/sequence",
        "Account type validated: must be ISA/MORTGAGE/SAVING/CURRENT/LOAN",
        "Whitespace validation: rejects spaces, low-values, start-with-space",
        "Temporal validation: opened_date must be after customer DOB",
        "Initial balances set to 0.00 (available and actual)",
        "Account creation logged in PROCTRAN with appropriate code",
        "get_account handles special mode 99999999 (alternative logic)",
        "update_account explicitly prohibits balance updates",
        "Updatable fields: account_type, interest_rate, overdraft_limit, statement dates",
        "Overdraft limit validation: must be >= 0",
        "delete_account validates customer and account type match",
        "Deletion is idempotent (already-deleted returns success)",
        "All deletions logged in PROCTRAN",
        "Database operations wrapped with retry logic"
      ],
      "relatedRequirements": ["FR-2", "FR-8", "FR-19", "FR-22", "FR-34", "FR-35", "FR-41", "NFR-39"],
      "skillsRequired": ["Python", "SQLAlchemy", "Business Logic"],
      "deliverables": [
        "backend/app/services/account_service.py"
      ]
    },
    {
      "id": "TASK-011",
      "title": "Create Transaction Processing Service with Specialized Rules",
      "description": "Create backend/app/services/transaction_service.py with class TransactionService. Implement process_transfer(from_account_number: str, to_account_number: str, amount: Decimal, db: Session) -> ProcTran: 1) Validate amount > 0, reject if zero or negative, 2) Validate from_account_number != to_account_number (prohibit same-account transfers), 3) Fetch both accounts, 4) CRITICAL: Do NOT check overdraft limits for transfers (differs from debits), 5) Begin database transaction, 6) Deduct amount from source account: available_balance -= amount, actual_balance -= amount, 7) Add amount to destination account: available_balance += amount, actual_balance += amount, 8) Create PROCTRAN record with transaction_code='TFR', both account IDs, amount, timestamp, 9) Commit transaction atomically, 10) On any failure, rollback, 11) Return transaction record. Implement process_debit(account_number: str, amount: Decimal, description: str, db: Session) -> ProcTran: 1) Validate amount > 0, 2) Fetch account, 3) Check account_type: if MORTGAGE or LOAN and accessed via PAYMENT facility, apply restrictions, 4) CRITICAL: Validate sufficient funds: check available_balance >= amount, raise InsufficientFundsException if not, 5) Begin transaction, 6) Deduct from balances: available_balance -= amount, actual_balance -= amount, 7) Create PROCTRAN with code='DEB', 8) Commit atomically, 9) Rollback on failure. Implement process_credit(account_number: str, amount: Decimal, description: str, db: Session) -> ProcTran: 1) Validate amount > 0, 2) Fetch account, 3) Add to balances: available_balance += amount, actual_balance += amount, 4) Create PROCTRAN with code='CRE', 5) Commit atomically. Add function validate_dual_balance_consistency() checking available and actual balances match business rules. All functions must: log operations before and after execution, use retry logic for deadlocks/timeouts, ensure ACID properties, maintain audit trail in PROCTRAN.",
      "suggestedPhase": "PHASE-02",
      "priority": "high",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-004", "TASK-005", "TASK-008", "TASK-010"],
      "acceptanceCriteria": [
        "process_transfer validates amount > 0 (rejects zero/negative)",
        "Same-account transfers prohibited (source != destination)",
        "CRITICAL: Transfers do NOT check overdraft limits",
        "Dual balance tracking: both available and actual updated",
        "Transfer transaction logged in PROCTRAN with code 'TFR'",
        "Atomic transaction: both accounts updated or neither",
        "process_debit validates sufficient funds before processing",
        "Debit operations DO check available_balance >= amount",
        "MORTGAGE/LOAN restrictions applied for PAYMENT facility",
        "Debit logged with code 'DEB'",
        "process_credit adds to both balance fields",
        "Credit logged with code 'CRE'",
        "Amount validation enforced across all transaction types",
        "All operations logged before and after execution",
        "Rollback occurs on any failure",
        "Retry logic handles deadlocks and timeouts",
        "Dual balance consistency validation implemented"
      ],
      "relatedRequirements": ["FR-4", "FR-21", "FR-24", "FR-42", "NFR-2", "NFR-21", "NFR-35", "NFR-36"],
      "skillsRequired": ["Python", "SQLAlchemy", "Transaction Management"],
      "deliverables": [
        "backend/app/services/transaction_service.py"
      ]
    },
    {
      "id": "TASK-012",
      "title": "Implement Credit Check Integration Service",
      "description": "Create backend/app/services/credit_check_service.py with class CreditCheckService. Implement async check_customer_credit(customer_id: int, customer_data: dict, db: Session) -> int: 1) Define 5 credit agency URLs (CRDTAGY1 through CRDTAGY5) from environment or config, 2) Create async tasks to call all 5 agencies concurrently using asyncio.gather, 3) For each agency call: set timeout to 3 seconds (random 0-3s for simulation), send customer data (name, DOB, address), parse response credit_score field, validate score is between 1-999, 4) Wrap each call with circuit breaker from TASK-008 (failure_threshold=5, timeout=30s), 5) On agency failure or timeout: default to score 0, mark customer for review (set marked_for_review=True), log failure with agency name, 6) Collect all returned scores (exclude failed agencies), 7) Calculate aggregated score: average of all successfully returned scores, 8) If all agencies fail: return 0 and mark for review, 9) Update customer record with credit_score and marked_for_review flag, 10) Log credit check results in audit trail, 11) Return final aggregated score. Implement simulate_credit_agency_response(customer_data: dict, agency_id: int) -> dict for testing: randomly delay 0-3 seconds, return random score 1-999 or occasionally simulate failure. Create integration tests mocking agency responses: test timeout handling, test partial failures (some agencies succeed, others fail), test aggregation algorithm (average), test circuit breaker opens after 5 failures, test all-failure scenario returns 0 and marks for review.",
      "suggestedPhase": "PHASE-03",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-008", "TASK-009"],
      "acceptanceCriteria": [
        "Async function calls 5 credit agencies concurrently",
        "Each agency call has 3-second timeout",
        "Credit score validation: range 1-999",
        "Circuit breaker pattern applied to each agency call",
        "Failed calls default to score 0",
        "Customer marked for review when credit check fails",
        "Aggregation algorithm: average of successfully returned scores",
        "All-failure scenario returns 0 and marks customer",
        "Customer record updated with credit_score and marked_for_review",
        "Credit check results logged in audit trail",
        "Integration tests verify timeout handling",
        "Tests verify partial failure scenarios",
        "Tests verify aggregation algorithm correctness",
        "Tests verify circuit breaker behavior"
      ],
      "relatedRequirements": ["FR-6", "FR-23", "NFR-6", "NFR-37"],
      "skillsRequired": ["Python", "Async Programming", "External APIs"],
      "deliverables": [
        "backend/app/services/credit_check_service.py",
        "backend/tests/test_credit_check_integration.py"
      ]
    },
    {
      "id": "TASK-013",
      "title": "Create Customer Management API Endpoints",
      "description": "Create backend/app/api/v1/endpoints/customers.py with APIRouter. Implement POST /customers endpoint: accept CustomerCreate schema, call customer_service.create_customer(), trigger async credit check (call credit_check_service.check_customer_credit in background), return 201 status with CustomerResponse. Implement GET /customers/{customer_number} endpoint: accept customer_number path parameter (handles special cases 0000000000, 9999999999), call customer_service.get_customer(), return 200 with CustomerResponse, return 404 if not found. Implement PUT /customers/{customer_number} endpoint: accept CustomerUpdate schema, call customer_service.update_customer(), return 200 with CustomerResponse. Implement DELETE /customers/{customer_number} endpoint: call customer_service.delete_customer() which handles cascading deletion, return 204 No Content on success, idempotent (returns 204 even if already deleted). Implement GET /customers endpoint: accept query params skip (default 0) and limit (default 100), call customer_service.list_customers() with pagination, return 200 with List[CustomerResponse]. Add authentication dependency using get_current_user from TASK-006. Add input sanitization to prevent injection attacks. Add rate limiting middleware. Register router in backend/app/api/v1/api.py with prefix '/customers'. Add OpenAPI documentation with examples for each endpoint. Create integration tests for all endpoints: test successful creation, test validation errors (invalid title, future DOB, age > 150, missing required fields), test special inquiry modes, test pagination, test cascading deletion.",
      "suggestedPhase": "PHASE-02",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-006", "TASK-009", "TASK-012"],
      "acceptanceCriteria": [
        "POST /customers endpoint creates customer and returns 201",
        "Credit check triggered asynchronously after customer creation",
        "GET /customers/{customer_number} handles special modes 0000000000 and 9999999999",
        "404 returned when customer not found",
        "PUT /customers/{customer_number} updates customer and returns 200",
        "All validation errors return 400 with detailed error messages",
        "DELETE /customers/{customer_number} implements cascading deletion",
        "Deletion is idempotent (returns 204 even if already deleted)",
        "GET /customers implements pagination with skip and limit",
        "All endpoints require authentication",
        "Input sanitization prevents injection attacks",
        "Rate limiting applied (100 requests per minute)",
        "OpenAPI documentation includes examples",
        "Integration tests cover all endpoints and edge cases"
      ],
      "relatedRequirements": ["FR-3", "FR-7", "FR-14", "FR-18", "NFR-19", "NFR-20"],
      "skillsRequired": ["Python", "FastAPI", "REST API"],
      "deliverables": [
        "backend/app/api/v1/endpoints/customers.py",
        "backend/tests/test_customers_api.py"
      ]
    },
    {
      "id": "TASK-014",
      "title": "Create Account Management API Endpoints",
      "description": "Create backend/app/api/v1/endpoints/accounts.py with APIRouter. Implement POST /accounts endpoint: accept AccountCreate schema with customer_id, validate customer exists, enforce 9-account limit per customer, call account_service.create_account(), return 201 with AccountResponse including generated account_number. Implement GET /accounts/{account_number} endpoint: handle special mode 99999999 (alternative retrieval), call account_service.get_account(), return 200 with AccountResponse including both balances, return 404 if not found. Implement PUT /accounts/{account_number} endpoint: accept AccountUpdate schema, CRITICAL: validate that balance fields are NOT included in update (reject with 400 Bad Request and message 'Balance updates not allowed via this endpoint, use transaction endpoints'), validate account_type not spaces/low-values, validate overdraft_limit >= 0, call account_service.update_account(), return 200 with AccountResponse. Implement DELETE /accounts/{account_number} endpoint: call account_service.delete_account(), return 204 No Content, idempotent behavior. Implement GET /customers/{customer_number}/accounts endpoint: call account_service.list_accounts_for_customer(), return 200 with List[AccountResponse]. Add authentication with get_current_user. Add validation for account_type whitespace. Register router with prefix '/accounts'. Create integration tests: test account creation with limit enforcement (attempt to create 10th account should fail), test special inquiry mode 99999999, test balance update rejection (attempt to update balance via PUT should return 400), test whitespace validation for account_type, test overdraft limit validation, test cascading deletion when customer deleted.",
      "suggestedPhase": "PHASE-02",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-006", "TASK-010", "TASK-013"],
      "acceptanceCriteria": [
        "POST /accounts creates account and returns 201 with generated account_number",
        "Account limit enforced: 9 accounts maximum per customer",
        "Attempting 10th account returns 400 with clear error message",
        "GET /accounts/{account_number} handles special mode 99999999",
        "Account response includes both available_balance and actual_balance",
        "PUT /accounts/{account_number} explicitly rejects balance updates",
        "Balance update attempt returns 400 with message about using transaction endpoints",
        "Account type whitespace validation (rejects spaces, low-values, start-with-space)",
        "Overdraft limit validation enforces >= 0",
        "DELETE /accounts/{account_number} is idempotent",
        "GET /customers/{customer_number}/accounts returns all customer accounts",
        "All endpoints require authentication",
        "Integration tests verify all business rules",
        "Tests verify account limit enforcement",
        "Tests verify balance update rejection"
      ],
      "relatedRequirements": ["FR-8", "FR-19", "FR-20", "FR-34", "FR-35", "FR-41"],
      "skillsRequired": ["Python", "FastAPI", "REST API"],
      "deliverables": [
        "backend/app/api/v1/endpoints/accounts.py",
        "backend/tests/test_accounts_api.py"
      ]
    },
    {
      "id": "TASK-015",
      "title": "Create Transaction Processing API Endpoints",
      "description": "Create backend/app/api/v1/endpoints/transactions.py with APIRouter. Implement POST /transactions/transfer endpoint: accept TransferRequest schema {from_account: str, to_account: str, amount: Decimal, description: str}, validate amount > 0, validate from_account != to_account (reject same-account with 400), call transaction_service.process_transfer(), return 201 with transaction details and new balances. Implement POST /transactions/debit endpoint: accept DebitRequest schema {account_number: str, amount: Decimal, description: str}, validate amount > 0, call transaction_service.process_debit(), handle InsufficientFundsException returning 400 with message, return 201 with transaction details. Implement POST /transactions/credit endpoint: accept CreditRequest schema, validate amount > 0, call transaction_service.process_credit(), return 201 with transaction details. Implement GET /accounts/{account_number}/transactions endpoint: query PROCTRAN filtered by account_id, support query params: limit (default 50), offset (default 0), start_date, end_date, transaction_code filter, order by transaction_timestamp DESC, return paginated List[TransactionResponse]. Implement GET /transactions/{transaction_id} endpoint: fetch single transaction, return 200 with details. Add idempotency using idempotency-key header: store processed transaction IDs in cache/database, return existing result if duplicate key. Add authentication. Add comprehensive error handling: 400 for validation errors (negative amounts, same-account transfers), 404 for account not found, 500 for database errors with retry exhausted. Register router with prefix '/transactions'. Create integration tests: test successful transfer between two accounts (verify both balances updated), test same-account transfer rejection, test debit with insufficient funds (should fail), test debit with sufficient funds, test credit operation, test amount validation (zero, negative), test idempotency (duplicate request returns same result), test transaction history pagination.",
      "suggestedPhase": "PHASE-02",
      "priority": "high",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-006", "TASK-011", "TASK-014"],
      "acceptanceCriteria": [
        "POST /transactions/transfer validates amount > 0",
        "Same-account transfers rejected with 400 status",
        "Transfer does NOT check overdraft limits (per business rule)",
        "Both account balances updated atomically in transfer",
        "POST /transactions/debit validates sufficient funds",
        "Insufficient funds returns 400 with clear error message",
        "POST /transactions/credit adds to account balance",
        "All transaction endpoints validate amount > 0 (reject zero and negative)",
        "GET /accounts/{account_number}/transactions returns paginated history",
        "Transaction history filterable by date range and transaction code",
        "Transactions ordered by timestamp descending (newest first)",
        "GET /transactions/{transaction_id} returns single transaction details",
        "Idempotency-key header prevents duplicate processing",
        "All endpoints require authentication",
        "Integration tests verify all transaction types",
        "Tests verify atomic operations and rollback on failure"
      ],
      "relatedRequirements": ["FR-4", "FR-15", "FR-17", "FR-24", "FR-42", "NFR-21"],
      "skillsRequired": ["Python", "FastAPI", "REST API", "Transactions"],
      "deliverables": [
        "backend/app/api/v1/endpoints/transactions.py",
        "backend/tests/test_transactions_api.py"
      ]
    },
    {
      "id": "TASK-016",
      "title": "Implement Batch Processing for Data Initialization",
      "description": "Create backend/app/services/batch_service.py with class BatchProcessingService. Implement process_customer_batch(customer_data: List[dict], db: Session) -> dict: 1) Accept list of customer dictionaries for bulk insert, 2) Process in batches of 1000 records, 3) For each batch: validate all records (title, DOB, required fields), begin transaction, insert all customers in batch, enforce 5 accounts maximum per customer in batch mode (different from online 9), validate account open_date > customer DOB for each account, commit transaction after each 1000 records, 4) On validation failure for any record: rollback entire batch, log error details, continue with next batch or abort based on config, 5) Track progress: records processed, records failed, total time, 6) Return summary: {total_processed, total_failed, duration, errors: []}. Implement generate_test_data(num_customers: int, accounts_per_customer: int) -> List[dict]: 1) Generate realistic test data: random names from list, random addresses, random DOB between 1950-2000, random account types, respect 5-account batch limit, ensure opened_date > DOB, 2) Return list of customer dictionaries with nested accounts. Create CLI script backend/scripts/run_batch_init.py: accept command-line args --file (CSV/JSON file path) or --generate (number of customers), parse input file or generate data, call batch_service.process_customer_batch(), display progress bar, print summary report. Implement performance optimization: use bulk_insert_mappings for SQLAlchemy, minimize queries with eager loading, ensure commit every 1000 records for recovery granularity. Add monitoring: log batch start/end times, track records per second, alert if batch takes > 5 minutes for 100K records. Create unit tests: test batch validation, test commit interval (verify commits every 1000), test rollback on validation failure, test 5-account limit enforcement in batch mode.",
      "suggestedPhase": "PHASE-02",
      "priority": "medium",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-004", "TASK-009", "TASK-010"],
      "acceptanceCriteria": [
        "Batch processing handles large datasets (100K+ records)",
        "Records processed in batches of 1000",
        "Transaction committed every 1000 records for recovery granularity",
        "Batch mode enforces 5 accounts maximum per customer",
        "Temporal validation: account opened_date > customer DOB",
        "Customer number range validation in batch mode",
        "Validation failure in batch triggers rollback of that batch only",
        "Progress tracking: records processed, failed, duration",
        "Performance target: 100K records in 5 minutes",
        "CLI script accepts file input or generates test data",
        "Generate test data creates realistic, valid records",
        "All generated data respects validation rules",
        "Progress bar displayed during batch processing",
        "Summary report printed: success count, failure count, duration",
        "Unit tests verify commit interval and rollback behavior"
      ],
      "relatedRequirements": ["FR-1", "FR-2", "FR-13", "FR-37", "NFR-1", "NFR-10", "NFR-39"],
      "skillsRequired": ["Python", "SQLAlchemy", "Batch Processing"],
      "deliverables": [
        "backend/app/services/batch_service.py",
        "backend/scripts/run_batch_init.py",
        "backend/tests/test_batch_processing.py"
      ]
    },
    {
      "id": "TASK-017",
      "title": "Create Customer Creation Frontend Form",
      "description": "Create frontend/src/components/CustomerForm.tsx using React Hook Form and Zod validation. Define Zod schema matching backend validation: title (enum with 10 values: Mr, Mrs, Miss, Ms, Dr, Professor, Drs, Lord, Sir, Lady), firstName (min 1 char), surname (min 1 char), dateOfBirth (date validation: not future, year > 1600, age < 150), addressLine1 (min 1 char), optional addressLine2/3, city, postalCode. Implement form with fields: title (dropdown), firstName (text input), surname (text input), dateOfBirth (date picker using react-datepicker), address fields (text inputs). Add real-time validation with inline error messages appearing within 100ms of input change. Add submit handler: call POST /api/v1/customers using axios, show loading spinner during submission, on success display success message and customer number, on error display error message with details from API response. Implement client-side date validation: calculate age in years, reject if > 150 or year < 1600 or future date. Style form using Tailwind CSS: responsive layout, clear labels, red error text, green success message, disabled submit button while loading. Create frontend/src/app/customers/new/page.tsx rendering CustomerForm component. Add navigation after successful creation to customer detail page. Create integration tests using React Testing Library: test form validation (invalid title shows error, future DOB shows error, age > 150 shows error, missing required fields shows error), test successful submission, test API error handling, test real-time validation feedback.",
      "suggestedPhase": "PHASE-03",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-001", "TASK-013"],
      "acceptanceCriteria": [
        "Customer form with all required fields rendered",
        "Title dropdown contains exactly 10 valid values",
        "Date picker for date of birth selection",
        "Zod schema validation matches backend rules",
        "Real-time validation with inline error messages",
        "Error messages appear within 100ms of input change",
        "First name, surname, address line 1 marked as required",
        "Date validation: rejects future dates, year < 1600, age > 150",
        "Submit button disabled while form invalid or submitting",
        "Loading spinner shown during API call",
        "Success message displays customer number on creation",
        "Error message displays API error details",
        "Form styled responsively with Tailwind CSS",
        "Integration tests verify all validation rules",
        "Tests verify error display and success flow"
      ],
      "relatedRequirements": ["FR-14", "FR-18", "FR-44", "FR-45", "FR-46", "NFR-17", "NFR-18"],
      "skillsRequired": ["React", "TypeScript", "Form Validation", "Tailwind CSS"],
      "deliverables": [
        "frontend/src/components/CustomerForm.tsx",
        "frontend/src/app/customers/new/page.tsx",
        "frontend/src/__tests__/CustomerForm.test.tsx"
      ]
    },
    {
      "id": "TASK-018",
      "title": "Create Account Creation Frontend Form",
      "description": "Create frontend/src/components/AccountForm.tsx with React Hook Form and Zod validation. Define schema: customerNumber (required, string), accountType (enum: ISA, MORTGAGE, SAVING, CURRENT, LOAN), interestRate (number, 0-100), overdraftLimit (number, >= 0), openedDate (date). Implement form with fields: customerNumber (text input with lookup button), accountType (dropdown with 5 options), interestRate (number input with % suffix), overdraftLimit (currency input with $ prefix), openedDate (date picker). Add customer lookup: button next to customerNumber triggers API call GET /customers/{number}, displays customer name when found, shows error if not found, validates customer exists before allowing form submission. Add validation: whitespace validation for accountType (reject spaces, low-values), overdraftLimit >= 0, opened date validation. Add account limit check: before submission, call GET /customers/{customerNumber}/accounts, count existing accounts, show warning if >= 8 accounts ('Creating 9th account - maximum allowed'), prevent submission if >= 9 accounts ('Cannot create account: customer has maximum 9 accounts'). Add submit handler: call POST /api/v1/accounts, on success show account number, on error show message. Handle validation errors: account limit exceeded (display specific message), customer not found, invalid account type. Create frontend/src/app/accounts/new/page.tsx rendering AccountForm. Style responsively. Create tests: test account type dropdown has 5 options, test customer lookup, test account limit enforcement (mock API returning 9 accounts shows error, prevents submission), test overdraft validation, test whitespace in account type rejected.",
      "suggestedPhase": "PHASE-03",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-001", "TASK-013", "TASK-014", "TASK-017"],
      "acceptanceCriteria": [
        "Account form with all required fields",
        "Account type dropdown has exactly 5 options (ISA, MORTGAGE, SAVING, CURRENT, LOAN)",
        "Customer lookup validates customer exists before submission",
        "Customer name displayed after successful lookup",
        "Account limit pre-check before submission",
        "Warning displayed when creating 9th account",
        "Error prevents submission when customer has 9 accounts",
        "Whitespace validation for account type",
        "Overdraft limit validation (>= 0)",
        "Interest rate validation (0-100%)",
        "Opened date validated",
        "Submit disabled while loading or form invalid",
        "Success message shows generated account number",
        "Error handling for all validation failures",
        "Responsive styling with Tailwind CSS",
        "Tests verify account limit enforcement"
      ],
      "relatedRequirements": ["FR-19", "FR-35", "FR-41", "NFR-17", "NFR-18"],
      "skillsRequired": ["React", "TypeScript", "Form Validation"],
      "deliverables": [
        "frontend/src/components/AccountForm.tsx",
        "frontend/src/app/accounts/new/page.tsx",
        "frontend/src/__tests__/AccountForm.test.tsx"
      ]
    },
    {
      "id": "TASK-019",
      "title": "Create Fund Transfer Frontend Interface",
      "description": "Create frontend/src/components/TransferForm.tsx with React Hook Form and Zod validation. Define schema: fromAccount (required string), toAccount (required string), amount (number > 0), description (optional string). Implement validation: amount must be > 0 (reject zero and negative), fromAccount !== toAccount (reject same-account transfers with message 'Cannot transfer to the same account'). Add account lookup for both fields: input with search/dropdown, call GET /api/v1/accounts/{accountNumber}, display account type and current balance when found, show error if account not found. Display current balance of source account prominently. Add amount input: currency formatted, shows validation error for zero/negative amounts. Add confirmation dialog before submission: shows summary (from account, to account, amount), requires user confirmation. Submit handler: call POST /api/v1/transactions/transfer, show loading state, on success: display success message, show new balances for both accounts, offer 'Make another transfer' button, on error: display error message (handle insufficient funds, account not found, same-account rejection). Create frontend/src/app/transactions/transfer/page.tsx rendering TransferForm. Style with clear visual hierarchy: source account on left, arrow icon in middle, destination on right. Create tests: test amount validation (zero rejected, negative rejected, positive accepted), test same-account rejection, test balance display, test confirmation dialog, test API error handling.",
      "suggestedPhase": "PHASE-03",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-001", "TASK-014", "TASK-015", "TASK-017"],
      "acceptanceCriteria": [
        "Transfer form with from account, to account, amount fields",
        "Account lookup for both source and destination",
        "Current balance displayed for source account",
        "Amount validation: must be > 0 (reject zero and negative)",
        "Same-account transfer validation: fromAccount !== toAccount",
        "Clear error message for same-account attempt",
        "Currency formatting for amount input",
        "Confirmation dialog before submission",
        "Summary shown in confirmation: accounts and amount",
        "Loading state during API call",
        "Success message shows new balances for both accounts",
        "Error handling for insufficient funds (though transfers don't check overdraft)",
        "Error handling for account not found",
        "Error handling for same-account rejection",
        "Responsive layout with clear visual flow",
        "Tests verify all validation rules and error cases"
      ],
      "relatedRequirements": ["FR-15", "FR-17", "FR-24", "FR-42", "NFR-17", "NFR-18"],
      "skillsRequired": ["React", "TypeScript", "UI/UX"],
      "deliverables": [
        "frontend/src/components/TransferForm.tsx",
        "frontend/src/app/transactions/transfer/page.tsx",
        "frontend/src/__tests__/TransferForm.test.tsx"
      ]
    },
    {
      "id": "TASK-020",
      "title": "Create System Health Monitoring Dashboard",
      "description": "Create backend/app/api/v1/endpoints/health.py with endpoints: GET /health returns {status: 'healthy', timestamp, version, database: {connected: bool, latency_ms}, services: {cache, queue}}. Add database health check: attempt simple query SELECT 1, measure latency, return connected=true if successful. GET /health/detailed (requires admin authentication) returns: system metrics (CPU, memory, disk usage), database metrics (connection pool stats, active connections, query performance), API metrics (request count, average response time, error rate), cache metrics. Create backend/app/services/metrics_service.py collecting: transaction volume (count per minute/hour/day), transaction success rate, average processing time per transaction type, error counts by error code, API endpoint usage statistics, database query performance. Store metrics in time-series database or PostgreSQL table with timestamp. Implement metric aggregation functions: calculate 95th percentile response time, calculate error rate percentage, identify slow queries. Create frontend/src/app/monitoring/page.tsx displaying dashboard with charts using recharts library: Line chart showing transaction volume over time, Pie chart showing transaction types distribution, Bar chart showing error counts by type, Gauge showing system health score (derived from error rate, response time, database health), Table showing recent errors with timestamp, error code, message. Add real-time updates using WebSocket or polling every 30 seconds. Create alert configuration in backend/app/services/alerts.py: define thresholds (error rate > 5%, response time > 500ms, transaction failure rate > 1%), check metrics every 5 minutes, send alert when threshold exceeded using alert notification function from TASK-007. Style dashboard professionally with dark theme option.",
      "suggestedPhase": "PHASE-04",
      "priority": "medium",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-002", "TASK-006", "TASK-007", "TASK-017"],
      "acceptanceCriteria": [
        "GET /health endpoint returns system status in JSON",
        "Database health check measures connection and latency",
        "GET /health/detailed requires admin authentication",
        "Detailed health includes system, database, API, cache metrics",
        "Metrics service collects transaction volume and success rate",
        "Transaction processing time tracked per transaction type",
        "Error counts tracked by error code",
        "Metrics stored with timestamps for historical analysis",
        "95th percentile response time calculated",
        "Dashboard displays line chart for transaction volume",
        "Dashboard shows error distribution and system health",
        "Real-time updates via WebSocket or 30-second polling",
        "Alert thresholds configurable",
        "Alerts triggered when metrics exceed thresholds",
        "Alerts sent within 5 minutes of threshold breach"
      ],
      "relatedRequirements": ["FR-28", "FR-29", "NFR-24", "NFR-27"],
      "skillsRequired": ["Python", "FastAPI", "React", "Monitoring"],
      "deliverables": [
        "backend/app/api/v1/endpoints/health.py",
        "backend/app/services/metrics_service.py",
        "backend/app/services/alerts.py",
        "frontend/src/app/monitoring/page.tsx"
      ]
    },
    {
      "id": "TASK-021",
      "title": "Implement Comprehensive Unit Tests for Customer Service",
      "description": "Create backend/tests/unit/test_customer_service.py using pytest. Mock database session using pytest fixtures. Test create_customer: test successful creation with valid data returns Customer object, test customer_number generation is unique, test eyecatcher 'CUST' is set automatically, test title validation (valid title accepted, invalid title raises ValidationException with clear message listing valid values), test DOB validation (future date raises exception with message 'Date of birth cannot be in the future', year 1600 accepted, year 1599 raises exception, age 150 rejected, age 149 accepted), test required fields (missing first_name raises exception, missing surname raises exception, missing address_line1 raises exception, empty string rejected, whitespace-only string rejected), test audit trail logging (verify log entry created). Test get_customer: test normal lookup by customer_number returns customer, test customer not found raises CustomerNotFoundException, test special mode 0000000000 returns random customer (mock database returning different customer each call, verify up to 1000 retry attempts), test special mode 9999999999 returns last customer (mock database ordering by id DESC), test retry logic on database error (mock OperationalError, verify retry attempts with backoff). Test update_customer: test successful update, test validation on update, test audit logging. Test delete_customer: test cascading deletion (mock customer with 3 accounts, verify all 3 accounts deleted first, verify customer deleted after accounts), test PROCTRAN logging for each deletion (verify 3 account logs + 1 customer log), test idempotency (delete already-deleted customer returns success), test retry on database error. Use pytest markers for different test categories. Aim for 95%+ code coverage on customer_service.py. Run tests with pytest --cov.",
      "suggestedPhase": "PHASE-04",
      "priority": "high",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-009"],
      "acceptanceCriteria": [
        "Unit tests for create_customer cover all validation rules",
        "Title validation tests verify all 10 valid values and reject invalid",
        "DOB validation tests: future date, year boundary (1600/1599), age boundary (149/150)",
        "Required field tests: missing, empty, whitespace-only",
        "Eyecatcher 'CUST' automatically set verified",
        "Audit trail logging verified",
        "get_customer tests verify special modes 0000000000 and 9999999999",
        "Random customer selection retry logic tested (up to 1000 attempts)",
        "CustomerNotFoundException properly raised and tested",
        "delete_customer tests verify cascading deletion order",
        "PROCTRAN logging verified for each deletion",
        "Idempotency tested (deleting already-deleted succeeds)",
        "Retry logic tested with mocked database errors",
        "Code coverage >= 95% for customer_service.py",
        "All tests pass with pytest"
      ],
      "relatedRequirements": ["FR-7", "FR-22", "FR-44", "FR-45", "FR-46", "NFR-22"],
      "skillsRequired": ["Python", "pytest", "Unit Testing"],
      "deliverables": [
        "backend/tests/unit/test_customer_service.py"
      ]
    },
    {
      "id": "TASK-022",
      "title": "Implement Comprehensive Unit Tests for Account Service",
      "description": "Create backend/tests/unit/test_account_service.py using pytest. Test create_account: test successful creation, test account_number generation, test customer validation (non-existent customer raises exception), test account limit enforcement (mock customer with 8 accounts, 9th account succeeds, attempt 10th account raises exception with message 'Cannot create account: customer has maximum 9 accounts'), test account_type validation (valid types ISA/MORTGAGE/SAVING/CURRENT/LOAN accepted, invalid type raises exception, spaces rejected with message, low-values rejected, starting-with-space rejected), test temporal validation (opened_date after customer DOB accepted, opened_date before DOB raises exception with message 'Account opened date must be after customer date of birth'), test initial balances set to 0.00 (verify both available_balance and actual_balance), test PROCTRAN logging with code OCA or ICA. Test get_account: test normal lookup, test special mode 99999999 (alternative retrieval logic), test account not found raises AccountNotFoundException, test account_type whitespace validation. Test update_account: test successful update of allowed fields (account_type, interest_rate, overdraft_limit, statement_dates), test balance update prohibition (mock AccountUpdate with balance field, verify exception raised with message 'Balance updates not allowed via this endpoint'), test overdraft_limit validation (negative value rejected, zero accepted, positive accepted), test account_type whitespace validation on update. Test delete_account: test successful deletion, test PROCTRAN logging with ODA or IDA code, test idempotency (deleting already-deleted succeeds), test customer and account_type matching validation. Test list_accounts_for_customer: test returns all accounts for customer, test empty list when no accounts. Mock database session. Aim for 95%+ code coverage.",
      "suggestedPhase": "PHASE-04",
      "priority": "high",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-010"],
      "acceptanceCriteria": [
        "Unit tests for create_account cover all validation rules",
        "Account limit enforcement tested (9 max, 10th fails)",
        "Account type validation: all 5 valid types, invalid types, whitespace",
        "Temporal validation tested: opened_date vs customer DOB",
        "Initial balances verified (0.00 for both available and actual)",
        "PROCTRAN logging verified with correct codes",
        "get_account special mode 99999999 tested",
        "update_account tests verify balance update prohibition",
        "Update tests verify only allowed fields can be updated",
        "Overdraft limit validation tested (negative rejected, >= 0 accepted)",
        "Account type whitespace validation on update tested",
        "delete_account idempotency tested",
        "PROCTRAN logging for deletion verified",
        "list_accounts_for_customer tested with accounts and empty list",
        "Code coverage >= 95% for account_service.py"
      ],
      "relatedRequirements": ["FR-8", "FR-19", "FR-22", "FR-34", "FR-35", "FR-41"],
      "skillsRequired": ["Python", "pytest", "Unit Testing"],
      "deliverables": [
        "backend/tests/unit/test_account_service.py"
      ]
    },
    {
      "id": "TASK-023",
      "title": "Implement Comprehensive Unit Tests for Transaction Service",
      "description": "Create backend/tests/unit/test_transaction_service.py using pytest. Test process_transfer: test successful transfer (verify both accounts updated, balances correct, PROCTRAN logged with code TFR), test amount validation (zero amount rejected, negative amount rejected, positive accepted), test same-account prohibition (from_account == to_account raises exception with message 'Cannot transfer to the same account'), test NO overdraft check (mock account with available_balance=100, transfer amount=150, verify transfer succeeds without checking overdraft - CRITICAL business rule), test dual balance update (verify both available_balance and actual_balance updated for both accounts), test atomic transaction (mock failure after first account update, verify both accounts rolled back), test retry on deadlock (mock OperationalError deadlock, verify retry with backoff), test PROCTRAN logging. Test process_debit: test successful debit, test amount validation (positive only), test sufficient funds validation (available_balance >= amount required, insufficient funds raises InsufficientFundsException with clear message), test MORTGAGE/LOAN restrictions (mock MORTGAGE account accessed via PAYMENT facility, verify restriction applied), test dual balance update (both balances decreased), test PROCTRAN logging with code DEB, test rollback on failure. Test process_credit: test successful credit, test amount validation, test dual balance update (both balances increased), test PROCTRAN logging with code CRE. Test validate_dual_balance_consistency: test balance discrepancy detection, test consistency validation. Mock database session and accounts. Verify all operations logged before and after execution. Aim for 95%+ code coverage.",
      "suggestedPhase": "PHASE-04",
      "priority": "high",
      "effortEstimate": "150 minutes",
      "dependencies": ["TASK-011"],
      "acceptanceCriteria": [
        "process_transfer tests verify successful transfer updates both accounts",
        "Amount validation tested (zero, negative, positive)",
        "Same-account prohibition tested with clear error message",
        "CRITICAL: Transfer does NOT check overdraft limits verified",
        "Test verifies transfer succeeds even when amount > available_balance",
        "Dual balance tracking tested (both balances updated)",
        "Atomic transaction tested (rollback on partial failure)",
        "Deadlock retry logic tested with mocked OperationalError",
        "PROCTRAN logging verified with code TFR",
        "process_debit sufficient funds validation tested",
        "Insufficient funds raises clear exception",
        "MORTGAGE/LOAN restrictions tested for PAYMENT facility",
        "process_credit tests verify balance increases",
        "All transaction types verify dual balance updates",
        "Consistency validation tested",
        "Code coverage >= 95% for transaction_service.py"
      ],
      "relatedRequirements": ["FR-24", "FR-42", "NFR-2", "NFR-21", "NFR-35", "NFR-36"],
      "skillsRequired": ["Python", "pytest", "Unit Testing"],
      "deliverables": [
        "backend/tests/unit/test_transaction_service.py"
      ]
    },
    {
      "id": "TASK-024",
      "title": "Implement Integration Tests for Complete Workflows",
      "description": "Create backend/tests/integration/ directory. Create test_customer_workflow.py testing complete customer lifecycle: 1) Create customer via POST /customers (verify 201 status, customer_number returned), 2) Verify credit check triggered (mock async call, verify customer.marked_for_review updated), 3) Retrieve customer via GET /customers/{number} (verify data matches), 4) Update customer via PUT (verify 200, updated fields), 5) Create 3 accounts for customer, 6) Delete customer via DELETE (verify cascading: all 3 accounts deleted first, then customer, PROCTRAN has 4 entries), 7) Verify idempotency: delete again returns 204. Create test_account_workflow.py: 1) Create customer, 2) Create 9 accounts for customer (all succeed), 3) Attempt 10th account (verify 400 error with message), 4) Update account (verify balance update rejected), 5) Delete account (verify success). Create test_transaction_workflow.py: 1) Create customer, 2) Create 2 accounts, 3) Credit 1000 to account 1, 4) Transfer 500 from account 1 to account 2 (verify balances: acct1=500, acct2=500), 5) Attempt transfer 600 from account 2 (verify succeeds even though > initial balance - no overdraft check), 6) Attempt debit 1000 from account 2 (verify fails with insufficient funds), 7) Verify transaction history via GET /accounts/{id}/transactions shows all operations. Create test_special_modes.py: test customer 0000000000 returns random customer, test customer 9999999999 returns last customer, test account 99999999 special handling. Use pytest fixtures for database setup/teardown, create test database, run migrations, seed initial data, cleanup after tests. Use TestClient for API testing. Implement parallel test execution with pytest-xdist. Create tests/conftest.py with shared fixtures.",
      "suggestedPhase": "PHASE-04",
      "priority": "high",
      "effortEstimate": "180 minutes",
      "dependencies": ["TASK-013", "TASK-014", "TASK-015", "TASK-021", "TASK-022", "TASK-023"],
      "acceptanceCriteria": [
        "Customer lifecycle integration test covers create, read, update, delete",
        "Credit check async trigger verified in customer creation",
        "Cascading deletion verified with PROCTRAN entries",
        "Idempotency verified (delete twice succeeds)",
        "Account workflow tests 9-account limit enforcement",
        "Balance update prohibition tested end-to-end",
        "Transaction workflow tests credit, transfer, debit operations",
        "Transfer without overdraft check verified (amount > balance succeeds)",
        "Debit with insufficient funds properly rejected",
        "Transaction history retrieval tested",
        "Special modes tested (0000000000, 9999999999, 99999999)",
        "Test database setup/teardown with fixtures",
        "All tests run against real database (integration level)",
        "Tests can run in parallel with pytest-xdist",
        "Shared fixtures in conftest.py"
      ],
      "relatedRequirements": ["FR-1", "FR-7", "FR-19", "FR-22", "FR-24", "NFR-22"],
      "skillsRequired": ["Python", "pytest", "Integration Testing"],
      "deliverables": [
        "backend/tests/integration/test_customer_workflow.py",
        "backend/tests/integration/test_account_workflow.py",
        "backend/tests/integration/test_transaction_workflow.py",
        "backend/tests/integration/test_special_modes.py",
        "backend/tests/conftest.py"
      ]
    },
    {
      "id": "TASK-025",
      "title": "Implement Frontend End-to-End Tests",
      "description": "Create frontend/e2e/ directory. Install Playwright for E2E testing: npm install @playwright/test. Create playwright.config.ts configuring: base URL http://localhost:3000, browsers (chromium, firefox, webkit), screenshots on failure, video on failure. Create e2e/customer-creation.spec.ts: 1) Navigate to /customers/new, 2) Fill form with invalid title (verify error), 3) Fill with future DOB (verify error 'Date of birth cannot be in the future'), 4) Fill with age > 150 (verify error), 5) Fill with missing required field (verify error), 6) Fill with valid data, 7) Submit form, 8) Verify success message with customer number, 9) Verify redirect to customer detail page. Create e2e/account-creation.spec.ts: 1) Create customer first, 2) Navigate to /accounts/new, 3) Lookup customer, 4) Create 9 accounts, 5) Attempt 10th account (verify error 'Cannot create account: customer has maximum 9 accounts'), 6) Verify error displayed in UI. Create e2e/fund-transfer.spec.ts: 1) Setup: create customer, create 2 accounts, credit 1000 to account 1, 2) Navigate to /transactions/transfer, 3) Select from-account (account 1), 4) Select to-account (same as from - verify error 'Cannot transfer to the same account'), 5) Change to account 2, 6) Enter amount 0 (verify error), 7) Enter amount -50 (verify error), 8) Enter amount 500, 9) Submit, 10) Verify confirmation dialog, 11) Confirm, 12) Verify success message with new balances. Create e2e/form-validation.spec.ts: test real-time validation (error appears within 100ms of invalid input), test all validation rules from forms. Create GitHub Actions workflow .github/workflows/e2e-tests.yml: run on pull request, setup Node.js and Python, start backend and frontend, run Playwright tests, upload test results and videos as artifacts. Configure test data cleanup after each test.",
      "suggestedPhase": "PHASE-04",
      "priority": "medium",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-017", "TASK-018", "TASK-019"],
      "acceptanceCriteria": [
        "Playwright configured with multiple browsers",
        "Customer creation E2E test covers all validation errors",
        "Future DOB error message verified in UI",
        "Age > 150 error verified in UI",
        "Required field validation verified in UI",
        "Successful customer creation and redirect tested",
        "Account creation E2E test creates 9 accounts",
        "10th account attempt shows error in UI",
        "Fund transfer E2E test covers all validation",
        "Same-account transfer shows error in UI",
        "Zero and negative amount validation tested in UI",
        "Confirmation dialog tested",
        "Real-time validation tested (< 100ms response)",
        "GitHub Actions workflow runs E2E tests on PR",
        "Test artifacts (screenshots, videos) uploaded on failure"
      ],
      "relatedRequirements": ["FR-14", "FR-17", "FR-18", "FR-19", "NFR-17", "NFR-18"],
      "skillsRequired": ["TypeScript", "Playwright", "E2E Testing"],
      "deliverables": [
        "frontend/e2e/customer-creation.spec.ts",
        "frontend/e2e/account-creation.spec.ts",
        "frontend/e2e/fund-transfer.spec.ts",
        "frontend/e2e/form-validation.spec.ts",
        "frontend/playwright.config.ts",
        ".github/workflows/e2e-tests.yml"
      ]
    },
    {
      "id": "TASK-026",
      "title": "Create Docker Configuration for Development and Production",
      "description": "Create Dockerfile.backend in backend/ directory: use Python 3.11 base image, install Poetry, copy pyproject.toml and install dependencies, copy application code, expose port 8000, set environment variables, run uvicorn with --host 0.0.0.0 --port 8000. Create Dockerfile.frontend in frontend/ directory: multi-stage build (builder stage: install dependencies and build Next.js, production stage: copy build artifacts, use Node 18 alpine), expose port 3000, run next start. Create docker-compose.yml at project root: define services (postgres, backend, frontend), postgres service with persistent volume, environment variables from .env file, health checks for each service, depends_on with conditions (backend depends on postgres, frontend depends on backend), networks for service communication. Create docker-compose.dev.yml for development: volume mounts for live code reload, expose ports for debugging, environment set to development. Create .dockerignore files excluding node_modules, __pycache__, .env, tests. Create scripts/docker-init.sh to initialize database: wait for postgres ready, run Alembic migrations, seed initial data. Create docs/DOCKER.md with instructions: how to build images, how to run development environment (docker-compose -f docker-compose.yml -f docker-compose.dev.yml up), how to run production (docker-compose up -d), how to view logs, how to run tests in containers, troubleshooting common issues. Add health check endpoints used by Docker. Configure PostgreSQL with persistent volume for data. Test full stack startup with docker-compose up, verify all services healthy, verify API accessible, verify database migrations applied, verify frontend loads.",
      "suggestedPhase": "PHASE-05",
      "priority": "high",
      "effortEstimate": "90 minutes",
      "dependencies": ["TASK-001", "TASK-002", "TASK-003"],
      "acceptanceCriteria": [
        "Dockerfile.backend builds successfully",
        "Backend container runs uvicorn server",
        "Dockerfile.frontend uses multi-stage build",
        "Frontend container serves Next.js production build",
        "docker-compose.yml defines all services (postgres, backend, frontend)",
        "PostgreSQL service has persistent volume",
        "Health checks configured for all services",
        "Service dependencies configured (backend depends on postgres)",
        "docker-compose.dev.yml enables live code reload",
        ".dockerignore excludes build artifacts and sensitive files",
        "Database initialization script runs migrations",
        "DOCKER.md documentation complete with examples",
        "Full stack starts with docker-compose up",
        "All services report healthy status",
        "API accessible from frontend container"
      ],
      "relatedRequirements": ["FR-26", "NFR-26", "NFR-28", "NFR-29"],
      "skillsRequired": ["Docker", "Docker Compose", "DevOps"],
      "deliverables": [
        "backend/Dockerfile.backend",
        "frontend/Dockerfile.frontend",
        "docker-compose.yml",
        "docker-compose.dev.yml",
        "backend/.dockerignore",
        "frontend/.dockerignore",
        "scripts/docker-init.sh",
        "docs/DOCKER.md"
      ]
    },
    {
      "id": "TASK-027",
      "title": "Create CI/CD Pipeline with GitHub Actions",
      "description": "Create .github/workflows/backend-ci.yml: trigger on push to main and pull requests, jobs (lint, test, build), lint job runs flake8 and black formatter check, test job runs pytest with coverage reporting (fail if coverage < 80%), build job builds Docker image and pushes to container registry (only on main branch), upload coverage report to Codecov. Create .github/workflows/frontend-ci.yml: trigger on push and PR, jobs (lint, test, build), lint runs ESLint and TypeScript compiler check, test runs Jest unit tests, build runs next build, upload build artifacts. Create .github/workflows/deploy-staging.yml: trigger on push to main, deploy to staging environment, jobs (build images, push to registry, deploy to staging server using SSH or cloud provider CLI, run database migrations, run smoke tests against staging). Create .github/workflows/deploy-production.yml: trigger manually (workflow_dispatch) or on release tag, require approval, build production images, push to production registry, deploy to production environment with blue-green strategy, run database migrations with backup, run smoke tests, rollback on failure. Create scripts/deploy.sh for deployment automation: pull latest images, stop old containers, start new containers, run health checks, rollback if health checks fail. Create .github/workflows/security-scan.yml: run Snyk or Trivy for dependency vulnerability scanning, scan Docker images, fail on high severity vulnerabilities. Add branch protection rules documentation requiring CI pass before merge. Create docs/CICD.md documenting pipeline stages, deployment process, rollback procedure, secrets management.",
      "suggestedPhase": "PHASE-05",
      "priority": "high",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-026"],
      "acceptanceCriteria": [
        "Backend CI workflow runs linting with flake8 and black",
        "Backend CI runs pytest with coverage requirement (80%+)",
        "Backend CI builds Docker image on main branch",
        "Frontend CI runs ESLint and TypeScript checks",
        "Frontend CI runs Jest unit tests",
        "Frontend CI builds Next.js successfully",
        "Staging deployment workflow deploys on main branch push",
        "Database migrations run automatically in staging",
        "Smoke tests run after staging deployment",
        "Production deployment requires manual approval",
        "Production deployment uses blue-green strategy",
        "Production deployment includes automatic rollback on failure",
        "Security scanning workflow detects vulnerabilities",
        "High severity vulnerabilities fail the build",
        "CICD.md documentation complete with examples"
      ],
      "relatedRequirements": ["FR-26", "NFR-16", "NFR-26"],
      "skillsRequired": ["GitHub Actions", "CI/CD", "DevOps"],
      "deliverables": [
        ".github/workflows/backend-ci.yml",
        ".github/workflows/frontend-ci.yml",
        ".github/workflows/deploy-staging.yml",
        ".github/workflows/deploy-production.yml",
        ".github/workflows/security-scan.yml",
        "scripts/deploy.sh",
        "docs/CICD.md"
      ]
    },
    {
      "id": "TASK-028",
      "title": "Create Comprehensive API Documentation",
      "description": "Create backend/app/api/v1/openapi.py customizing OpenAPI schema: add project description, version, contact information, license, add tags for endpoint grouping (Customers, Accounts, Transactions, Authentication, Health), add security scheme documentation (JWT Bearer token). For each API endpoint, enhance docstrings with: detailed description of operation, parameter descriptions, request body examples (show valid and invalid examples), response schemas for each status code (200, 201, 400, 401, 404, 500), example responses showing actual data structure. Create backend/docs/api/ directory with markdown files: AUTHENTICATION.md (how to obtain JWT token, how to use in requests, token expiration), CUSTOMERS.md (all customer endpoints with curl examples, special inquiry modes documentation), ACCOUNTS.md (all account endpoints, account limit rules, balance update prohibition), TRANSACTIONS.md (transaction endpoints, business rules for transfers vs debits, amount validation, dual balance tracking), ERRORS.md (error code reference with all possible error codes, descriptions, and resolution steps). Configure FastAPI to serve OpenAPI UI at /docs (Swagger UI) and /redoc (ReDoc). Create frontend API client documentation in frontend/docs/API_CLIENT.md: how to use API service, authentication handling, error handling patterns, TypeScript types for requests/responses. Create Postman collection with all API endpoints, environment variables for base URL and token, example requests for each endpoint, test scripts verifying responses. Export collection to backend/docs/api/postman_collection.json. Create docs/README.md as main entry point linking to all documentation. Test all API examples in documentation to ensure they work.",
      "suggestedPhase": "PHASE-05",
      "priority": "medium",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-013", "TASK-014", "TASK-015"],
      "acceptanceCriteria": [
        "OpenAPI schema customized with project information",
        "All endpoints have detailed docstrings with examples",
        "Request body examples show valid and invalid data",
        "Response schemas documented for all status codes",
        "AUTHENTICATION.md explains JWT token usage",
        "CUSTOMERS.md documents special inquiry modes (0000000000, 9999999999)",
        "ACCOUNTS.md documents account limit and balance prohibition",
        "TRANSACTIONS.md documents business rules (no overdraft on transfers)",
        "ERRORS.md provides complete error code reference",
        "Swagger UI accessible at /docs with all endpoints",
        "ReDoc accessible at /redoc",
        "Frontend API client documentation complete",
        "Postman collection includes all endpoints with examples",
        "All documented examples tested and working",
        "Main README.md links to all documentation"
      ],
      "relatedRequirements": ["FR-20", "NFR-19", "NFR-31"],
      "skillsRequired": ["Technical Writing", "OpenAPI", "Documentation"],
      "deliverables": [
        "backend/app/api/v1/openapi.py",
        "backend/docs/api/AUTHENTICATION.md",
        "backend/docs/api/CUSTOMERS.md",
        "backend/docs/api/ACCOUNTS.md",
        "backend/docs/api/TRANSACTIONS.md",
        "backend/docs/api/ERRORS.md",
        "backend/docs/api/postman_collection.json",
        "frontend/docs/API_CLIENT.md",
        "docs/README.md"
      ]
    },
    {
      "id": "TASK-029",
      "title": "Implement Database Backup and Disaster Recovery",
      "description": "Create scripts/backup-database.sh: use pg_dump to create PostgreSQL backup, compress backup with gzip, include timestamp in filename (backup_YYYYMMDD_HHMMSS.sql.gz), upload to cloud storage (S3 or equivalent) or network storage, verify backup integrity by checking file size and performing test restore to temporary database, log backup operation with status (success/failure), send notification on failure. Create scripts/restore-database.sh: download latest backup from storage, verify backup file integrity, stop application services, create backup of current database before restore, restore from backup file using psql, verify restoration by checking record counts and running validation queries, restart application services, run smoke tests, log restoration operation. Implement automated backup schedule: create cron job or scheduled task running daily at 2 AM, keep last 30 daily backups, keep weekly backups for 3 months, keep monthly backups for 1 year, implement backup rotation policy to delete old backups. Create disaster recovery documentation in docs/DISASTER_RECOVERY.md: RTO (Recovery Time Objective) = 4 hours, RPO (Recovery Point Objective) = 1 hour (with continuous replication), backup schedule and retention policy, step-by-step restoration procedure, failover procedure for database, contact list for disaster recovery team, runbook for common disaster scenarios. Implement database replication: setup PostgreSQL streaming replication to standby server, configure automatic failover using tools like Patroni or manual failover procedure, test failover annually. Create scripts/test-backup-restore.sh to verify backups can be restored: perform test restore to temporary database, run validation queries, compare record counts with production. Document backup verification in disaster recovery plan. Create monitoring alerts for backup failures.",
      "suggestedPhase": "PHASE-05",
      "priority": "high",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-003", "TASK-026"],
      "acceptanceCriteria": [
        "Backup script creates compressed PostgreSQL dump",
        "Backup includes timestamp in filename",
        "Backup uploaded to remote storage",
        "Backup integrity verified with test restore",
        "Restore script downloads and verifies backup",
        "Current database backed up before restoration",
        "Restoration verified with validation queries",
        "Automated daily backups at 2 AM configured",
        "Backup retention policy: 30 daily, 3 months weekly, 1 year monthly",
        "DISASTER_RECOVERY.md documents RTO of 4 hours",
        "RPO of 1 hour documented and achievable",
        "Step-by-step restoration procedure documented",
        "Failover procedure documented",
        "Database replication configured to standby",
        "Backup verification script tests restores",
        "Alerts configured for backup failures"
      ],
      "relatedRequirements": ["NFR-24", "NFR-25"],
      "skillsRequired": ["PostgreSQL", "Backup/Restore", "Disaster Recovery"],
      "deliverables": [
        "scripts/backup-database.sh",
        "scripts/restore-database.sh",
        "scripts/test-backup-restore.sh",
        "docs/DISASTER_RECOVERY.md"
      ]
    },
    {
      "id": "TASK-030",
      "title": "Create Project Documentation and Setup Guide",
      "description": "Create comprehensive README.md at project root: project overview (Legacy Banking System Modernization), features list (customer management, account management, transaction processing, credit checks, batch processing), technology stack (Next.js, Python FastAPI, PostgreSQL), architecture diagram (high-level component diagram showing frontend, backend API, database, external services), quick start guide (prerequisites, installation steps, running locally), links to detailed documentation. Create docs/ARCHITECTURE.md: system architecture overview, component diagram, data flow diagrams, database schema diagram (ERD showing CUSTOMER, ACCOUNT, PROCTRAN relationships and constraints), API architecture (REST principles, authentication flow, error handling), security architecture. Create docs/DEVELOPMENT.md: development environment setup (install Node.js, Python, PostgreSQL), running locally (step-by-step instructions), project structure explanation (directory layout for both frontend and backend), coding standards (Python PEP 8, TypeScript/React best practices), git workflow (branching strategy, commit message format, PR process), testing guide (how to run unit tests, integration tests, E2E tests). Create docs/DEPLOYMENT.md: deployment architecture (staging and production environments), deployment process (CI/CD pipeline usage), environment variables reference (list all required env vars with descriptions), database migrations (how to create and apply), monitoring and logging, troubleshooting guide. Create docs/BUSINESS_RULES.md documenting critical business rules: account limits (9 online, 5 batch), transaction rules (transfers no overdraft check, debits do check), validation rules (titles, DOB, age, amounts), special modes (customer 0000000000, 9999999999, account 99999999), cascading deletion, dual balance tracking. Create CONTRIBUTING.md: how to contribute, code of conduct, PR checklist (tests pass, code formatted, documentation updated). Create CHANGELOG.md tracking version history. Add badges to README.md: build status, code coverage, license.",
      "suggestedPhase": "PHASE-05",
      "priority": "medium",
      "effortEstimate": "120 minutes",
      "dependencies": ["TASK-001", "TASK-002", "TASK-003", "TASK-028"],
      "acceptanceCriteria": [
        "README.md provides clear project overview",
        "Quick start guide enables new developer to run project locally",
        "Architecture diagram shows system components and relationships",
        "ARCHITECTURE.md documents system design",
        "Database ERD shows all tables, relationships, and constraints",
        "DEVELOPMENT.md explains development setup completely",
        "Project structure documented for both frontend and backend",
        "Coding standards defined and linked to style guides",
        "DEPLOYMENT.md covers staging and production deployment",
        "All environment variables documented with descriptions",
        "BUSINESS_RULES.md documents all critical rules discovered in requirements",
        "Special modes (0000000000, 9999999999, 99999999) documented",
        "Account limits (9 vs 5) explained",
        "Transaction rules (overdraft behavior) documented",
        "CONTRIBUTING.md encourages community contributions",
        "Build status and coverage badges in README.md"
      ],
      "relatedRequirements": ["NFR-5", "NFR-31"],
      "skillsRequired": ["Technical Writing", "Documentation"],
      "deliverables": [
        "README.md",
        "docs/ARCHITECTURE.md",
        "docs/DEVELOPMENT.md",
        "docs/DEPLOYMENT.md",
        "docs/BUSINESS_RULES.md",
        "CONTRIBUTING.md",
        "CHANGELOG.md"
      ]
    }
  ],
  "suggested_new_phases": [],
  "additional_tasks_summary": {
    "total_requirements_covered": 121,
    "requirements_needing_additional_tasks": [
      "FR-3 (Customer Account Inquiry - covered in TASK-013)",
      "FR-11 (Control Table - requires additional batch control task)",
      "FR-16 (Configuration Management - requires configuration service task)",
      "FR-25 (Retry and Rollback - covered in TASK-008)",
      "FR-27 (Schema Migration - covered in TASK-003)",
      "FR-30 (Centralized Logging - covered in TASK-007)",
      "FR-31 (Data Structure Standards - covered throughout)",
      "FR-32 (Error Tracking Structures - covered in TASK-007)",
      "FR-33 (Date/Time Standards - covered in schemas)",
      "FR-39 (Facility Type Codes - lower priority, deferred)",
      "FR-40 (Transaction Status - covered in TASK-011)",
      "FR-43 (Diagnostic Dump - covered in monitoring)",
      "NFR-4 (Scalability - covered in architecture)",
      "NFR-11 (Database Scalability - covered in schema design)",
      "NFR-15 (Data Encryption - additional security task needed)",
      "NFR-23 (Async Processing - covered in credit check)",
      "NFR-30 (Data Structure Versioning - covered in API versioning)"
    ],
    "notes": "The 30 tasks above cover the high and medium priority requirements comprehensively. Additional tasks can be created for remaining lower-priority features, advanced monitoring, performance optimization, and security hardening as needed. The tasks are designed to be executed sequentially by AI agents with clear acceptance criteria and dependencies."
  }
}
