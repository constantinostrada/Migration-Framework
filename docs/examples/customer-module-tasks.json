{
  "project_name": "Legacy Banking System",
  "framework_version": "4.1-clean-arch",
  "total_tasks": 9,
  "tasks": [
    {
      "id": "TASK-001-CONTRACTS",
      "title": "Generate Customer Module Contracts",
      "description": "Create complete contract specifications for Customer module in output/legacy-banking/contracts/Customer/:\n\n1. Create openapi.yaml:\n   - Define POST /customers endpoint with CustomerCreate schema (name, email, phone, address, credit_score)\n   - Define GET /customers/{id} endpoint with Customer schema\n   - Define PUT /customers/{id} endpoint with CustomerUpdate schema\n   - Include error responses: 400 (validation), 404 (not found), 409 (duplicate email)\n   - Add examples for all requests/responses\n   - Use snake_case for all field names\n\n2. Create types.ts:\n   - Export interface CustomerCreate with fields: name (string), address (string), email (string), phone (string), credit_score (number)\n   - Export interface Customer extends CustomerCreate with: id (string), created_at (string), updated_at (string)\n   - Export interface CustomerUpdate as Partial<CustomerCreate>\n   - All interfaces must match OpenAPI schema exactly\n\n3. Create schema.sql:\n   - CREATE TABLE customers with columns: id (UUID PRIMARY KEY DEFAULT gen_random_uuid()), name (VARCHAR(255) NOT NULL), address (TEXT), email (VARCHAR(255) UNIQUE NOT NULL), phone (VARCHAR(20)), credit_score (INTEGER CHECK (credit_score >= 0 AND credit_score <= 850)), created_at (TIMESTAMP DEFAULT NOW()), updated_at (TIMESTAMP DEFAULT NOW())\n   - CREATE INDEX idx_customers_email ON customers(email)\n   - CREATE TRIGGER update_customers_updated_at BEFORE UPDATE ON customers FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()\n\n4. Create error-codes.json:\n   - CUST-001: Customer not found (404)\n   - CUST-002: Customer email already exists (409)\n   - CUST-003: Invalid credit score (400)\n   - CUST-004: Credit assessment failed - score below minimum threshold (400)",
      "type": "contracts",
      "module": "Customer",
      "phase": "PHASE-01-Foundation",
      "priority": "high",
      "implementation_layer": null,
      "assigned_to": "orchestrator",
      "status": "pending",
      "dependencies": [],
      "layer_dependencies": {},
      "related_requirements": ["FR-001", "FR-002", "FR-003", "FR-004"],
      "business_rules": [],
      "deliverables": [
        "output/legacy-banking/contracts/Customer/openapi.yaml",
        "output/legacy-banking/contracts/Customer/types.ts",
        "output/legacy-banking/contracts/Customer/schema.sql",
        "output/legacy-banking/contracts/Customer/error-codes.json"
      ],
      "acceptance_criteria": [
        "openapi.yaml validates with swagger-cli",
        "types.ts compiles with tsc --noEmit",
        "schema.sql has no syntax errors",
        "All fields from CustomerCreate in types.ts match OpenAPI schema exactly",
        "All error codes reference specific HTTP status codes"
      ],
      "validation_commands": [
        "swagger-cli validate output/legacy-banking/contracts/Customer/openapi.yaml",
        "tsc --noEmit output/legacy-banking/contracts/Customer/types.ts"
      ],
      "effort_estimate": "30 minutes",
      "skills_required": ["OpenAPI", "TypeScript", "SQL"],
      "created_at": "2026-01-01T10:00:00Z"
    },
    {
      "id": "TASK-002-QA-ENRICH",
      "title": "Enrich Customer Tasks with TDD Test Specifications",
      "description": "For each Customer implementation task, add comprehensive test_strategy specifications.\n\nThis task is handled by qa-test-generator agent which will:\n1. Read all Customer tasks\n2. Read requirements.json for acceptance criteria\n3. Generate unit/integration/e2e test specifications\n4. Add test_strategy to each implementation task\n5. Update tasks.json with enriched specifications",
      "type": "tests",
      "module": "Customer",
      "phase": "PHASE-01-Foundation",
      "priority": "high",
      "implementation_layer": null,
      "assigned_to": "qa-test-generator",
      "status": "pending",
      "dependencies": ["TASK-001-CONTRACTS"],
      "layer_dependencies": {},
      "related_requirements": ["FR-001", "FR-002", "FR-003", "FR-004"],
      "deliverables": [
        "docs/state/tasks.json (updated with test_strategy for all tasks)"
      ],
      "acceptance_criteria": [
        "All implementation tasks have test_strategy defined",
        "Test cases cover happy path, error cases, and edge cases",
        "Each test case has clear arrange-act-assert structure",
        "Coverage target set to 0.90 (90%)"
      ],
      "validation_commands": [],
      "effort_estimate": "20 minutes",
      "skills_required": ["TDD", "Test Design"],
      "created_at": "2026-01-01T10:30:00Z"
    },
    {
      "id": "TASK-003-DOMAIN",
      "title": "Create Customer Domain Entity and Value Objects",
      "description": "Create domain layer for Customer module in backend/app/domain/:\n\n1. Create domain/entities/customer.py:\n   - Define Customer entity class (pure Python, NO SQLAlchemy)\n   - Attributes: id (UUID), name (str), email (Email value object), credit_score (CreditScore value object), address (str), phone (str), created_at (datetime), updated_at (datetime)\n   - Constructor validates all fields using value objects\n   - Method: assess_credit() -> bool (returns True if credit_score.value >= 700)\n   - Method: can_open_account() -> bool (implements business rule BR-CUST-001)\n   - Method: update_email(new_email: Email) -> None\n   - NO database dependencies, pure domain logic\n   - Use dataclass or regular class with __init__\n\n2. Create domain/value_objects/email.py:\n   - Email value object with validation (regex: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$)\n   - Immutable (frozen dataclass or property)\n   - __eq__ and __hash__ for value equality\n   - Raise ValueError if invalid format\n\n3. Create domain/value_objects/credit_score.py:\n   - CreditScore value object\n   - Validation: 0 <= score <= 850\n   - Immutable\n   - Method: is_acceptable() -> bool (>= 700)\n   - Raise ValueError if out of range\n\nIMPORTANT: Absolutely NO imports from SQLAlchemy, FastAPI, or any framework. Pure Python domain logic only.",
      "type": "implementation",
      "module": "Customer",
      "phase": "PHASE-02-Core",
      "priority": "high",
      "implementation_layer": "domain",
      "execution_order": 1,
      "assigned_to": "domain-agent",
      "status": "pending",
      "dependencies": ["TASK-001-CONTRACTS", "TASK-002-QA-ENRICH"],
      "layer_dependencies": {},
      "related_requirements": ["FR-001", "FR-002"],
      "business_rules": ["BR-CUST-001: Credit assessment required - credit score must be >= 700"],
      "test_strategy": {
        "unit_tests": [
          {
            "file_path": "tests/unit/domain/entities/test_customer.py",
            "test_cases": [
              {
                "name": "test_customer_creation_valid",
                "scenario": "happy_path",
                "description": "Should create customer entity with valid data",
                "arrange": "Prepare valid customer data: name='John Doe', email='john@example.com', credit_score=750",
                "act": "customer = Customer(id=uuid4(), name=name, email=Email(email), credit_score=CreditScore(750), ...)",
                "assert": "Customer created successfully, can_open_account() returns True"
              },
              {
                "name": "test_customer_low_credit_score",
                "scenario": "business_rule",
                "description": "Should reject account opening when credit score < 700",
                "arrange": "Create customer with credit_score=650",
                "act": "result = customer.can_open_account()",
                "assert": "Returns False"
              },
              {
                "name": "test_customer_boundary_credit_score",
                "scenario": "boundary",
                "description": "Should accept exactly 700 credit score",
                "arrange": "Create customer with credit_score=700",
                "act": "result = customer.can_open_account()",
                "assert": "Returns True"
              }
            ],
            "mocks_required": []
          },
          {
            "file_path": "tests/unit/domain/value_objects/test_email.py",
            "test_cases": [
              {
                "name": "test_email_valid",
                "scenario": "happy_path",
                "description": "Should create Email value object with valid email",
                "arrange": "email_string = 'test@example.com'",
                "act": "email = Email(email_string)",
                "assert": "Email object created, email.value == 'test@example.com'"
              },
              {
                "name": "test_email_invalid_format",
                "scenario": "error_case",
                "description": "Should raise ValueError for invalid email format",
                "arrange": "email_string = 'invalid-email'",
                "act": "Email(email_string)",
                "assert": "ValueError raised with message 'Invalid email format'"
              }
            ],
            "mocks_required": []
          },
          {
            "file_path": "tests/unit/domain/value_objects/test_credit_score.py",
            "test_cases": [
              {
                "name": "test_credit_score_valid",
                "scenario": "happy_path",
                "description": "Should create CreditScore with valid value",
                "arrange": "score_value = 750",
                "act": "score = CreditScore(score_value)",
                "assert": "CreditScore created, is_acceptable() returns True"
              },
              {
                "name": "test_credit_score_out_of_range",
                "scenario": "error_case",
                "description": "Should raise ValueError for score > 850",
                "arrange": "score_value = 900",
                "act": "CreditScore(score_value)",
                "assert": "ValueError raised"
              },
              {
                "name": "test_credit_score_negative",
                "scenario": "error_case",
                "description": "Should raise ValueError for negative score",
                "arrange": "score_value = -100",
                "act": "CreditScore(score_value)",
                "assert": "ValueError raised"
              }
            ],
            "mocks_required": []
          }
        ],
        "integration_tests": [],
        "coverage_target": 0.95
      },
      "deliverables": [
        "backend/app/domain/entities/customer.py",
        "backend/app/domain/value_objects/email.py",
        "backend/app/domain/value_objects/credit_score.py",
        "tests/unit/domain/entities/test_customer.py",
        "tests/unit/domain/value_objects/test_email.py",
        "tests/unit/domain/value_objects/test_credit_score.py"
      ],
      "acceptance_criteria": [
        "Customer entity has ZERO framework dependencies (no SQLAlchemy, FastAPI, etc.)",
        "Business rule BR-CUST-001 enforced in can_open_account() method",
        "Value objects are immutable",
        "All unit tests pass 100%",
        "Code coverage >= 95%"
      ],
      "validation_commands": [
        "pytest tests/unit/domain/ -v --cov=backend/app/domain --cov-report=term-missing"
      ],
      "effort_estimate": "45 minutes",
      "estimated_complexity": 0.6,
      "skills_required": ["Python", "DDD", "Clean Architecture", "Value Objects"],
      "created_at": "2026-01-01T11:00:00Z"
    },
    {
      "id": "TASK-004-USE-CASE",
      "title": "Create Customer Use Cases and Application Layer",
      "description": "Create application layer for Customer module in backend/app/application/:\n\n1. Create application/interfaces/customer_repository.py (INTERFACE ONLY):\n   - from abc import ABC, abstractmethod\n   - Define ICustomerRepository(ABC) abstract class\n   - @abstractmethod async def save(customer: Customer) -> Customer\n   - @abstractmethod async def find_by_id(customer_id: UUID) -> Optional[Customer]\n   - @abstractmethod async def find_by_email(email: Email) -> Optional[Customer]\n   - @abstractmethod async def update(customer: Customer) -> Customer\n   - @abstractmethod async def exists_by_email(email: Email) -> bool\n\n2. Create application/dtos/customer_dto.py:\n   - from pydantic import BaseModel, EmailStr, Field\n   - CustomerCreateDTO: name, email (EmailStr), phone, address, credit_score (int, ge=0, le=850)\n   - CustomerDTO (response): id (UUID), name, email, phone, address, credit_score, created_at, updated_at\n   - CustomerUpdateDTO: Partial fields (all optional)\n\n3. Create application/use_cases/create_customer.py:\n   - Class CreateCustomerUseCase\n   - Constructor: inject repository: ICustomerRepository\n   - async def execute(dto: CustomerCreateDTO) -> CustomerDTO:\n     * Create Email value object from dto.email\n     * Create CreditScore value object from dto.credit_score\n     * Check if email exists: exists = await self.repository.exists_by_email(email)\n     * If exists: raise DuplicateEmailError (custom exception)\n     * Create Customer entity from domain\n     * Validate customer.can_open_account() (business rule BR-CUST-001)\n     * If not valid: raise CreditAssessmentFailedError\n     * Save: saved_customer = await self.repository.save(customer)\n     * Convert to DTO and return\n\n4. Create application/use_cases/get_customer.py:\n   - Class GetCustomerUseCase\n   - async def execute(customer_id: UUID) -> CustomerDTO:\n     * customer = await repository.find_by_id(customer_id)\n     * If None: raise CustomerNotFoundError\n     * Convert to DTO and return\n\n5. Create application/use_cases/update_customer.py:\n   - Class UpdateCustomerUseCase\n   - async def execute(customer_id: UUID, dto: CustomerUpdateDTO) -> CustomerDTO:\n     * Get customer using repository.find_by_id\n     * If not found: raise CustomerNotFoundError\n     * Update fields from dto (only non-None values)\n     * If email changed: validate new email and check uniqueness\n     * If credit_score changed: revalidate can_open_account()\n     * Save updated customer\n     * Return DTO\n\n6. Create application/exceptions.py:\n   - CustomerNotFoundError\n   - DuplicateEmailError\n   - CreditAssessmentFailedError\n   - All inherit from ApplicationError base class\n\nIMPORTANT: Use domain entities. Repository is INTERFACE only (not implementation). NO SQLAlchemy imports.",
      "type": "implementation",
      "module": "Customer",
      "phase": "PHASE-02-Core",
      "priority": "high",
      "implementation_layer": "use_case",
      "execution_order": 2,
      "assigned_to": "use-case-agent",
      "status": "pending",
      "dependencies": ["TASK-003-DOMAIN"],
      "layer_dependencies": {
        "domain": ["TASK-003-DOMAIN"]
      },
      "related_requirements": ["FR-001", "FR-002", "FR-003", "FR-004"],
      "business_rules": ["BR-CUST-001: Credit assessment required"],
      "test_strategy": {
        "unit_tests": [
          {
            "file_path": "tests/unit/application/use_cases/test_create_customer.py",
            "test_cases": [
              {
                "name": "test_create_customer_success",
                "scenario": "happy_path",
                "description": "Should create customer successfully with valid data",
                "arrange": "Mock repository, prepare valid CustomerCreateDTO with credit_score=750",
                "act": "result = await use_case.execute(dto)",
                "assert": "CustomerDTO returned with id, repository.save called once, repository.exists_by_email called"
              },
              {
                "name": "test_create_customer_duplicate_email",
                "scenario": "error_case",
                "description": "Should raise DuplicateEmailError when email exists",
                "arrange": "Mock repository.exists_by_email to return True",
                "act": "await use_case.execute(dto)",
                "assert": "DuplicateEmailError raised, repository.save NOT called"
              },
              {
                "name": "test_create_customer_low_credit_score",
                "scenario": "business_rule",
                "description": "Should raise CreditAssessmentFailedError when score < 700",
                "arrange": "Mock repository, prepare DTO with credit_score=650",
                "act": "await use_case.execute(dto)",
                "assert": "CreditAssessmentFailedError raised, repository.save NOT called"
              }
            ],
            "mocks_required": ["ICustomerRepository"]
          },
          {
            "file_path": "tests/unit/application/use_cases/test_get_customer.py",
            "test_cases": [
              {
                "name": "test_get_customer_found",
                "scenario": "happy_path",
                "description": "Should return customer DTO when found",
                "arrange": "Mock repository.find_by_id to return Customer entity",
                "act": "result = await use_case.execute(customer_id)",
                "assert": "CustomerDTO returned with correct data"
              },
              {
                "name": "test_get_customer_not_found",
                "scenario": "error_case",
                "description": "Should raise CustomerNotFoundError when not found",
                "arrange": "Mock repository.find_by_id to return None",
                "act": "await use_case.execute(customer_id)",
                "assert": "CustomerNotFoundError raised"
              }
            ],
            "mocks_required": ["ICustomerRepository"]
          }
        ],
        "integration_tests": [],
        "coverage_target": 0.90
      },
      "deliverables": [
        "backend/app/application/interfaces/customer_repository.py",
        "backend/app/application/dtos/customer_dto.py",
        "backend/app/application/use_cases/create_customer.py",
        "backend/app/application/use_cases/get_customer.py",
        "backend/app/application/use_cases/update_customer.py",
        "backend/app/application/exceptions.py",
        "tests/unit/application/use_cases/test_create_customer.py",
        "tests/unit/application/use_cases/test_get_customer.py",
        "tests/unit/application/use_cases/test_update_customer.py"
      ],
      "acceptance_criteria": [
        "Use cases orchestrate domain logic correctly",
        "Repository is INTERFACE only (no implementation)",
        "Business rules validated via domain entities",
        "All unit tests with mocked repository pass 100%",
        "DTOs use Pydantic for validation",
        "Custom exceptions defined for all error cases"
      ],
      "validation_commands": [
        "pytest tests/unit/application/ -v --cov=backend/app/application --cov-report=term-missing"
      ],
      "effort_estimate": "60 minutes",
      "estimated_complexity": 0.7,
      "skills_required": ["Python", "Clean Architecture", "Use Cases", "Pydantic"],
      "created_at": "2026-01-01T11:45:00Z"
    },
    {
      "id": "TASK-005-INFRA-DB",
      "title": "Implement Customer Infrastructure - Database Layer",
      "description": "Create infrastructure database layer for Customer in backend/app/infrastructure/database/:\n\n1. Create infrastructure/database/models/customer_model.py:\n   - from sqlalchemy import Column, String, Integer, DateTime, UUID\n   - from sqlalchemy.orm import declarative_base\n   - CustomerModel(Base) class matching schema.sql exactly\n   - All columns with proper SQLAlchemy types\n   - __tablename__ = 'customers'\n   - Method: to_domain(self) -> Customer (converts ORM model to domain entity)\n     * Create Email and CreditScore value objects\n     * Return Customer entity\n   - Static method: from_domain(customer: Customer) -> CustomerModel\n     * Convert domain entity to ORM model\n     * Extract value from value objects (email.value, credit_score.value)\n\n2. Create infrastructure/database/repositories/customer_repository_impl.py:\n   - Class CustomerRepositoryImpl(ICustomerRepository) implements interface\n   - Constructor: def __init__(self, session: AsyncSession)\n   - Implement all interface methods using SQLAlchemy:\n     * async def save(customer: Customer) -> Customer:\n       - model = CustomerModel.from_domain(customer)\n       - session.add(model)\n       - await session.commit()\n       - await session.refresh(model)\n       - return model.to_domain()\n     * async def find_by_id(customer_id: UUID) -> Optional[Customer]\n     * async def find_by_email(email: Email) -> Optional[Customer]\n     * async def update(customer: Customer) -> Customer\n     * async def exists_by_email(email: Email) -> bool\n   - Always convert between domain entities and ORM models\n\n3. Create infrastructure/database/config.py:\n   - Database connection configuration\n   - AsyncSession factory\n   - Engine creation\n\nIMPORTANT: This implements the interface from use-case layer. Always convert domain â†” ORM.",
      "type": "implementation",
      "module": "Customer",
      "phase": "PHASE-02-Core",
      "priority": "high",
      "implementation_layer": "infrastructure",
      "execution_order": 3,
      "assigned_to": "infrastructure-agent",
      "status": "pending",
      "dependencies": ["TASK-004-USE-CASE"],
      "layer_dependencies": {
        "domain": ["TASK-003-DOMAIN"],
        "use_case": ["TASK-004-USE-CASE"]
      },
      "related_requirements": ["FR-001", "FR-002", "FR-003", "FR-004"],
      "test_strategy": {
        "integration_tests": [
          {
            "file_path": "tests/integration/infrastructure/database/test_customer_repository.py",
            "test_cases": [
              {
                "name": "test_save_customer",
                "scenario": "happy_path",
                "description": "Should save customer to database and return domain entity",
                "arrange": "Create test database session, create Customer domain entity",
                "act": "saved_customer = await repository.save(customer)",
                "assert": "Customer saved to DB, ID generated, domain entity returned"
              },
              {
                "name": "test_find_by_id_found",
                "scenario": "happy_path",
                "description": "Should find customer by ID",
                "arrange": "Save customer to test DB",
                "act": "found = await repository.find_by_id(customer.id)",
                "assert": "Customer found, domain entity returned with correct data"
              },
              {
                "name": "test_find_by_id_not_found",
                "scenario": "error_case",
                "description": "Should return None when customer not found",
                "arrange": "Empty test database",
                "act": "found = await repository.find_by_id(uuid4())",
                "assert": "Returns None"
              },
              {
                "name": "test_exists_by_email_true",
                "scenario": "happy_path",
                "description": "Should return True when email exists",
                "arrange": "Save customer with email 'test@example.com'",
                "act": "exists = await repository.exists_by_email(Email('test@example.com'))",
                "assert": "Returns True"
              }
            ],
            "dependencies_required": ["test_database", "async_session"]
          }
        ],
        "unit_tests": [],
        "coverage_target": 0.85
      },
      "deliverables": [
        "backend/app/infrastructure/database/models/customer_model.py",
        "backend/app/infrastructure/database/repositories/customer_repository_impl.py",
        "backend/app/infrastructure/database/config.py",
        "tests/integration/infrastructure/database/test_customer_repository.py"
      ],
      "acceptance_criteria": [
        "Repository implements ICustomerRepository interface correctly",
        "Conversion between domain entities and ORM models works correctly",
        "All integration tests with real test database pass 100%",
        "SQLAlchemy models match schema.sql exactly",
        "Async/await used correctly throughout"
      ],
      "validation_commands": [
        "pytest tests/integration/infrastructure/database/ -v"
      ],
      "effort_estimate": "50 minutes",
      "estimated_complexity": 0.7,
      "skills_required": ["SQLAlchemy", "AsyncIO", "PostgreSQL", "ORM"],
      "created_at": "2026-01-01T12:45:00Z"
    },
    {
      "id": "TASK-006-INFRA-API",
      "title": "Implement Customer Infrastructure - API Layer",
      "description": "Create FastAPI REST API for Customer in backend/app/infrastructure/api/:\n\n1. Create infrastructure/api/dependencies.py:\n   - Dependency injection functions\n   - async def get_db() -> AsyncSession (yields database session)\n   - async def get_customer_repository(session: AsyncSession = Depends(get_db)) -> ICustomerRepository:\n     return CustomerRepositoryImpl(session)\n   - async def get_create_customer_use_case(repo = Depends(get_customer_repository)) -> CreateCustomerUseCase:\n     return CreateCustomerUseCase(repo)\n   - Similar for other use cases\n\n2. Create infrastructure/api/customer.py:\n   - from fastapi import APIRouter, Depends, HTTPException, status\n   - router = APIRouter(prefix='/customers', tags=['customers'])\n   \n   - @router.post('/', response_model=CustomerDTO, status_code=status.HTTP_201_CREATED)\n     async def create_customer(\n       dto: CustomerCreateDTO,\n       use_case: CreateCustomerUseCase = Depends(get_create_customer_use_case)\n     ):\n       try:\n         return await use_case.execute(dto)\n       except DuplicateEmailError:\n         raise HTTPException(409, detail={\"error_code\": \"CUST-002\", \"message\": \"Email already exists\"})\n       except CreditAssessmentFailedError:\n         raise HTTPException(400, detail={\"error_code\": \"CUST-004\", \"message\": \"Credit assessment failed\"})\n   \n   - @router.get('/{customer_id}', response_model=CustomerDTO)\n     async def get_customer(\n       customer_id: UUID,\n       use_case: GetCustomerUseCase = Depends(get_get_customer_use_case)\n     ):\n       try:\n         return await use_case.execute(customer_id)\n       except CustomerNotFoundError:\n         raise HTTPException(404, detail={\"error_code\": \"CUST-001\", \"message\": \"Customer not found\"})\n   \n   - @router.put('/{customer_id}', response_model=CustomerDTO)\n     async def update_customer(...)\n\n3. Update backend/app/main.py:\n   - from infrastructure.api.customer import router as customer_router\n   - app.include_router(customer_router)\n\nIMPORTANT: Map domain exceptions to HTTP errors with correct status codes and error codes from error-codes.json.",
      "type": "implementation",
      "module": "Customer",
      "phase": "PHASE-02-Core",
      "priority": "high",
      "implementation_layer": "infrastructure",
      "execution_order": 4,
      "assigned_to": "infrastructure-agent",
      "status": "pending",
      "dependencies": ["TASK-005-INFRA-DB"],
      "layer_dependencies": {
        "domain": ["TASK-003-DOMAIN"],
        "use_case": ["TASK-004-USE-CASE"],
        "infrastructure": ["TASK-005-INFRA-DB"]
      },
      "related_requirements": ["FR-001", "FR-002", "FR-003", "FR-004"],
      "test_strategy": {
        "integration_tests": [
          {
            "file_path": "tests/integration/infrastructure/api/test_customer_api.py",
            "test_cases": [
              {
                "name": "test_post_customers_success",
                "scenario": "happy_path",
                "description": "Should create customer via API",
                "arrange": "TestClient, prepare valid CustomerCreateDTO payload",
                "act": "response = client.post('/customers', json=payload)",
                "assert": "Status 201, response body contains customer with id, created_at, updated_at"
              },
              {
                "name": "test_post_customers_duplicate_email",
                "scenario": "error_case",
                "description": "Should return 409 for duplicate email",
                "arrange": "Create customer via API, prepare payload with same email",
                "act": "response = client.post('/customers', json=payload)",
                "assert": "Status 409, error_code CUST-002 in response body"
              },
              {
                "name": "test_post_customers_low_credit_score",
                "scenario": "business_rule",
                "description": "Should return 400 when credit score < 700",
                "arrange": "Prepare payload with credit_score=650",
                "act": "response = client.post('/customers', json=payload)",
                "assert": "Status 400, error_code CUST-004 in response"
              },
              {
                "name": "test_get_customer_found",
                "scenario": "happy_path",
                "description": "Should retrieve customer by ID",
                "arrange": "Create customer, get ID",
                "act": "response = client.get(f'/customers/{customer_id}')",
                "assert": "Status 200, customer data in response"
              },
              {
                "name": "test_get_customer_not_found",
                "scenario": "error_case",
                "description": "Should return 404 when customer not found",
                "arrange": "Random UUID",
                "act": "response = client.get(f'/customers/{random_uuid}')",
                "assert": "Status 404, error_code CUST-001 in response"
              }
            ],
            "dependencies_required": ["TestClient", "test_database"]
          }
        ],
        "unit_tests": [],
        "coverage_target": 0.90
      },
      "deliverables": [
        "backend/app/infrastructure/api/dependencies.py",
        "backend/app/infrastructure/api/customer.py",
        "backend/app/main.py (updated)",
        "tests/integration/infrastructure/api/test_customer_api.py"
      ],
      "acceptance_criteria": [
        "All endpoints match OpenAPI spec exactly",
        "Response models match DTOs",
        "Status codes match spec (201, 200, 400, 404, 409)",
        "Error codes from error-codes.json used correctly",
        "All integration tests pass 100%",
        "Endpoints visible in /docs (Swagger UI)",
        "Dependency injection configured correctly"
      ],
      "validation_commands": [
        "pytest tests/integration/infrastructure/api/ -v",
        "curl http://localhost:8000/docs | grep '/customers'"
      ],
      "effort_estimate": "45 minutes",
      "estimated_complexity": 0.6,
      "skills_required": ["FastAPI", "Dependency Injection", "REST API"],
      "created_at": "2026-01-01T13:35:00Z"
    },
    {
      "id": "TASK-007-UI-DESIGN",
      "title": "Design Customer Form UI with shadcn/ui Components",
      "description": "Research and design UI for Customer creation form using shadcn/ui components.\n\nThis task is handled by shadcn-ui-agent (research subagent) which will:\n1. Read contracts/Customer/openapi.yaml (POST /customers endpoint)\n2. Read contracts/Customer/types.ts (CustomerCreateDTO)\n3. Read contracts/Customer/error-codes.json\n4. Use MCP shadcn/ui tools to research appropriate components\n5. Design component structure and layout\n6. Create detailed UI design document\n\nOutput: docs/ui-design/customer-form-design.md with:\n- Component selection (Form, Input, Button, Alert, Card)\n- Component structure (tree)\n- Validation schema (zod)\n- State management approach\n- Error handling for all error codes\n- Accessibility plan\n- Responsive design strategy\n- Installation commands",
      "type": "ui_design",
      "module": "Customer",
      "phase": "PHASE-02-Core",
      "priority": "high",
      "implementation_layer": null,
      "assigned_to": "shadcn-ui-agent",
      "status": "pending",
      "dependencies": ["TASK-001-CONTRACTS", "TASK-006-INFRA-API"],
      "layer_dependencies": {},
      "related_requirements": ["FR-001"],
      "deliverables": [
        "docs/ui-design/customer-form-design.md"
      ],
      "acceptance_criteria": [
        "All shadcn/ui components justified",
        "Component structure documented",
        "Validation schema defined",
        "Error handling for CUST-002, CUST-004 specified",
        "Accessibility considerations included",
        "Installation commands provided"
      ],
      "validation_commands": [],
      "effort_estimate": "25 minutes",
      "skills_required": ["UI Design", "shadcn/ui", "React"],
      "created_at": "2026-01-01T14:20:00Z"
    },
    {
      "id": "TASK-008-INFRA-FRONTEND",
      "title": "Implement Customer Frontend",
      "description": "Implement frontend for Customer module using Next.js 13+ and shadcn/ui.\n\nBefore implementation, read: docs/ui-design/customer-form-design.md\n\n1. Install shadcn/ui components (from design doc):\n   - npx shadcn-ui@latest add form input button card alert label\n\n2. Create frontend/src/api/customer.ts (API client):\n   - Import Customer, CustomerCreate types from contracts\n   - async function createCustomer(data: CustomerCreate): Promise<Customer>\n   - async function getCustomer(id: string): Promise<Customer>\n   - async function updateCustomer(id: string, data: Partial<CustomerCreate>): Promise<Customer>\n   - Error handling for 409, 400, 404\n\n3. Create frontend/src/components/Customer/CustomerForm.tsx:\n   - Follow structure from UI design doc exactly\n   - Use react-hook-form + zod validation\n   - Fields: name, email, phone, address, credit_score\n   - Display errors from API (CUST-002, CUST-004)\n   - Loading state during submission\n   - Redirect to /customers/{id} on success\n\n4. Create frontend/src/components/Customer/CustomerDetail.tsx:\n   - Display customer information\n   - Edit button linking to /customers/{id}/edit\n\n5. Create frontend/src/app/customers/new/page.tsx:\n   - Import CustomerForm\n   - Metadata export\n   - Server component\n\n6. Create frontend/src/app/customers/[id]/page.tsx:\n   - Fetch customer data\n   - Display CustomerDetail\n   - Handle loading/error states\n\n7. Create frontend/src/app/customers/page.tsx:\n   - List customers (simple version)\n   - Link to /customers/new\n\nIMPORTANT: Follow UI design document exactly. Use shadcn/ui components as specified.",
      "type": "implementation",
      "module": "Customer",
      "phase": "PHASE-02-Core",
      "priority": "high",
      "implementation_layer": "infrastructure",
      "execution_order": 5,
      "assigned_to": "infrastructure-agent",
      "status": "pending",
      "dependencies": ["TASK-007-UI-DESIGN"],
      "layer_dependencies": {
        "infrastructure": ["TASK-006-INFRA-API"]
      },
      "related_requirements": ["FR-001", "FR-003"],
      "test_strategy": {
        "e2e_tests": [
          {
            "file_path": "tests/e2e/Customer/test_create_customer_flow.spec.ts",
            "test_cases": [
              {
                "name": "User can create customer via form",
                "scenario": "happy_path",
                "description": "Complete flow from form submission to success",
                "arrange": "Navigate to /customers/new",
                "act": "Fill form with valid data (name, email, phone, address, credit_score=750), click submit",
                "assert": "Redirected to /customers/{id}, success message shown, customer data displayed correctly"
              },
              {
                "name": "Form shows validation errors",
                "scenario": "error_case",
                "description": "Client-side validation errors displayed",
                "arrange": "Navigate to /customers/new",
                "act": "Fill form with invalid email, try to submit",
                "assert": "Form not submitted, error message shown under email field"
              },
              {
                "name": "Form shows duplicate email error",
                "scenario": "error_case",
                "description": "API error (409) displayed to user",
                "arrange": "Create customer with email, navigate to /customers/new",
                "act": "Fill form with same email, submit",
                "assert": "Alert shown with 'Email already exists' message"
              }
            ],
            "pages_involved": ["/customers/new", "/customers/{id}"]
          }
        ],
        "unit_tests": [],
        "integration_tests": [],
        "coverage_target": 0.80
      },
      "deliverables": [
        "frontend/src/api/customer.ts",
        "frontend/src/components/Customer/CustomerForm.tsx",
        "frontend/src/components/Customer/CustomerDetail.tsx",
        "frontend/src/app/customers/new/page.tsx",
        "frontend/src/app/customers/[id]/page.tsx",
        "frontend/src/app/customers/page.tsx",
        "tests/e2e/Customer/test_create_customer_flow.spec.ts"
      ],
      "acceptance_criteria": [
        "All pages follow Next.js 13+ app router conventions",
        "shadcn/ui components used as per design doc",
        "Form validation works (client-side with zod)",
        "API errors displayed correctly (CUST-002, CUST-004)",
        "Loading states handled",
        "Responsive design (mobile, tablet, desktop)",
        "TypeScript compiles without errors",
        "Accessibility features present (ARIA labels, keyboard nav)"
      ],
      "validation_commands": [
        "npm run build",
        "tsc --noEmit",
        "npm run dev"
      ],
      "effort_estimate": "90 minutes",
      "estimated_complexity": 0.8,
      "skills_required": ["Next.js", "React", "TypeScript", "shadcn/ui", "react-hook-form", "zod"],
      "created_at": "2026-01-01T14:45:00Z"
    },
    {
      "id": "TASK-009-E2E-QA",
      "title": "Execute E2E Tests for Customer Module",
      "description": "Execute E2E tests and report failures for Customer module.\n\nThis task will be handled by e2e-qa-agent which will:\n1. Run: npx playwright test tests/e2e/Customer/\n2. Capture screenshots of failures\n3. Analyze each failure:\n   - Category (backend_logic, frontend_rendering, validation, etc.)\n   - Root cause\n   - Affected file and line\n   - Suggested fix\n4. Write detailed report to: docs/qa/e2e-report-Customer-iter-1.json\n5. Update global-state.json with pass_rate\n\nOrchestrator will then fix failures and re-run until pass_rate >= 95% (max 5 iterations).",
      "type": "e2e_testing",
      "module": "Customer",
      "phase": "PHASE-04-QA",
      "priority": "high",
      "implementation_layer": null,
      "assigned_to": "e2e-qa-agent",
      "status": "pending",
      "dependencies": ["TASK-008-INFRA-FRONTEND"],
      "layer_dependencies": {},
      "related_requirements": ["FR-001", "FR-002", "FR-003", "FR-004"],
      "deliverables": [
        "docs/qa/e2e-report-Customer-iter-1.json"
      ],
      "acceptance_criteria": [
        "All E2E tests executed",
        "Failures categorized and analyzed",
        "Screenshots captured for visual failures",
        "Report written with actionable fixes",
        "Pass rate >= 95% OR detailed failure report provided"
      ],
      "validation_commands": [
        "npx playwright test tests/e2e/Customer/"
      ],
      "effort_estimate": "15 minutes per iteration",
      "skills_required": ["Playwright", "Test Analysis", "Debugging"],
      "created_at": "2026-01-01T16:15:00Z",
      "execution_metrics": {
        "e2e_iterations": 0,
        "e2e_pass_rate": 0.0
      }
    }
  ],
  "generated_at": "2026-01-01T10:00:00Z",
  "generated_by": "orchestrator",
  "summary": {
    "pending": 9,
    "in_progress": 0,
    "completed": 0,
    "failed": 0,
    "blocked": 0
  }
}
